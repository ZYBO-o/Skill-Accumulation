## 一. **刷题**

### 1. 链表

+  从尾到头打印链表
+  链表中倒数最后k个结点
+  反转链表
+  合并两个有序链表
+  复杂链表的复制
+  两个链表的第一个公共结点
+  链表中环的入口结点

+  删除链表中重复的结点

---

##  二 .C++

### C相关问题

+  **C程序如何启动和终止的**
   + 内核调用一个exec函数，调用exec的进程将命令行参数传递给启动例程，然后启动例程调用main函数。
   + 进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用\_exit或 \_Exit。进程也可非自愿地由一个信号使其终止。

+  **atexit函数**
   + atexit函数类似于C++类中的析构函数，在main函数结束之后被exit调用，调用顺序与登记顺序相反。同一函数如若登记多次也会被调用多次。
   + `atexit`的参数是一个函数地址，无需传递参数,也不期望返回值。

+  **C程序的存储地址空间布局**
   + 从低地址往高地址分别为： 正文段—> 初始化数据段—> 未初始化数据段—> 堆——>栈。
   + 它们的主要作用：
     + 正文段：这部分是共享的，也是只读的，是CPU执行的机器指令部分。
     + 初始化数据段：包含程序中需明确地赋初值的变量
     + 未初始化数据段：也称为bss段( block started by symbol)，在程序执行之前，内核将该段中的数据初始化为0或空指针。
     + 堆：动态分配存储的区域
     + 栈：自动变量以及函数调用所需要保存信息的区域

+  **讲一下存储空间分配函数——malloc, realloc, calloc各自的用法**
   + `void *malloc(size_t size);`  分配指定字节数的存储区，初始值不确定
   + `void *calloc(size_t nobj, size_t size);` 分配指定 数目，长度 的存储空间， 初始化为0
   + `void *realloc(void *ptr, size_t newsize);` 增加或减少以前分配区的长度，新增区初始值不确定
+  **C++ 中的 string 与 C 中的 `char *` 有什么区别？**
   + string继承自 basic_string ，是对 `char` 进行了封装，包含 char 数组，容量，长度等属性
   + string可以动态扩展，每次扩展是原空间的两倍，将原内容拷贝进去。

### C++基本介绍

---

+  struct和union的区别
+  介绍auto,主要是会覆盖顶层的引用和修饰。
+  如果要保留顶层的引用和修饰要用什么？decltype
+  什么是字节对齐
+  知道虚函数表指针在内存中是怎么分布的吗？(我直接按照Lippman那本书回答)。
+  虚函数表指针放在头部和尾部的好处分别是什么？(自己挖的坑。。)

---

+ 聊一聊C++面向对象的三大特性

  > C++ 的三大特性就是继承，封装和多态。

  + 继承：让某种类型对象获得另一个类型对象的属性和方法。有三种继承方式：
    + 实现继承：指使用基类的属性和方法而无需额外编码的能力
    + 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    + 可视继承：(C++里好像不怎么用)
  + 封装：变量和方法捆绑成类，可以对它们进行信息隐藏，只让可信的对象和类操作。
  + 多态：同一事物表现出不同事物的能力。实现多态的两种方式：
    + 覆盖： 是指子类重新定义父类的虚函数的做法。
    + 重载：是指允许存在多个同名函数，而函数的参数表不同

### 变量与基本类型

---

+  **变量与定义的区别**
   + 声明仅仅将变量声明的位置与类型提供给编译器，并不分配内存。定义会在定义的地方直接分配存储空间。
   + 相同变量可在多处声明，但只能一处定义。
+  **什么情况下必须用到初始化成员列表**
   + 初始化const成员
   + 初始化reference成员
   + 调用基类的构造函数，该函数有参数
   + 调用数据成员对象的构造函数，该函数有参数
+  **常量指针与指针常量的区别**
   + 常量指针指常量的指针，注重常量，不能修改指定的值 ：`int const *p` 或 `const int *p`
   + 指针常量指不能修改指针的指向，指针是一个常量： `int *const p` 。
+  **介绍野指针与空悬指针，如何避免？**
   + 野指针：没有初始化的指针
   + 空悬指针： 指针最初指向的内存已经被释放了的一种指针。
   + 解决方法：使用完置空，或者使用智能指针。

---

## 三. STL







---

## 四.调试

### 1.gdb



### 2.makefile



---

## 五. 链接与编译

### 1.编译与链接过程

+  一个程序从开始运行到结束的完整过程，你能说出来多少?

---

+  **静态链接与动态链接的区别？ 什么是共享库？**

  + 预编译： 运行C预处理器(cpp)将C的源程序 hello.c 翻译成一个ASCII码的中间文件 hello.i. 

    >  `gcc -E hello.c -o hello.i`

  + 编译：驱动程序运行C编译器(gcc)，将hello.i翻一个一个ASCII汇编语言文件hello.s

    >  `gcc -S hell0.i -o hello.s`

  + 汇编：运行汇编器(as)，将 hello.s 翻译成一个可重定位目标文件 hello.o

    > `gcc -c hell0.s -o hello.o`

  + 链接： 运行连接器程序**(ld)**，将**hello.o**和一些必要的系统目标文件组合起来，创建一个可执行文件**prog**:

    > `gcc hell0.o -o hello`

    + 将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接:
      + 静态链接：
        + 对函数库的链接是放在编译时期完成的是静态链接 。 所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。 所有需要的函数已复制到相关位置 。Linux下文件名为`lib**.a`的形式 。
      + 动态链接：
        + 基本思想是把程序按照模块拆分成各个相对独立部分，库函数的链接载入推迟到程序运行时才链接在一起形成一个完整的程序，动态库文件名`lib**.so`。

---

+   介绍一下静态库与动态库的创建与使用
  + 解决动态链接库失败的问题

+  gcc 与 g++ 的区别？

---

### 2.目标文件

+  **目标文件是什么？有哪几种类型？**

---

## 六. 计算机网络

### 0.计算机网络基础

+ OSI的七层模型是什么？有哪些功能
+ 计算机网络体系为什么要按照现有体系进行分层？
+  网络的七层/五层模型主要的协议有哪些？

### 1.网络层



### 2.TCP层





---

### 3.HTTP层

+ 键入网址到网⻚显示，期间发生了什么?

+  Linux系统是如何收发网络包的？

---

## 七.操作系统

### Linux 命令

+ linux 中查看监听网络端口命令，more和cat的区别



+ linux 改密码命令 改权限命令

 

+  如何结束一个进程， -9 是什么含义



+ ps的底层实现(我按照自己的理解，讲了一下PCB的机制，然后说大概是扫描了一下PCB的[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)，面试官好像挺满意的)。

+ 对于大文件，为什么CP比MV慢很多
+ 如果rm以及rm -f一个正在被使用的文件，会发生什么

### 进程与线程

+ 两个进程会存放在相同的内存地址吗？讲几种进程调度的算法？进程的状态有哪几种？哪些操作会使进程从用户态到内核态呢？
+ Linux进程地址空间分布
+ Linux内存管理方法，页面置换[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，逻辑地址和物理地址的转换
+ 生产-消费者模型，伪代码，用条件变量，注意使用while()替代if()判断是否满足条件
+ C++20里的协程，所以又问了我协程相关的东西，包括内核线程和用户态线程之类的。
+ 为什么要区分内核和用户态
+ linux怎么管理进程内存？
+ 怎么快速定位linux下占用资源很大的程序单元
+ 哪些时候会发生上下文切换，上下文切换过程中经历了什么

---

+  **进程，线程和协程的区别和联系**
   + 定义：
     + 进程： 进程是在内存中运行着的程序，是资源分配和拥有的基本单位
     + 线程：线程是轻量级的进程，是最小的执行单位
     + 协程：用户态的轻量级线程，线程内部调度的基本单位
   + 区别：
     1. **切换情况：**
        + 进程：进程CPU环境的保存以及 新调度的进程CPU环境的设置 ；涉及栈、寄存器、页表和文件句柄等
        + 线程：保存和设置程序计数器，少量寄存器和栈的内容
        + 协程：先将寄存器上下文和栈保存，等切换回来的时候再进行恢复
     2. **切换者**
        + 进程：操作系统
        + 线程：操作系统
        + 协程：用户
     3. **切换过程**
        + 进程：用户态—>内核态—>用户态
        + 线程：用户态—>内核态—>用户态
        + 协程：只有用户态
     4. **调用栈**
        + 进程：内核栈
        + 线程：内核栈
        + 协程：用户栈
     5. **拥有资源**
        + 进程：CPU资源，内存资源，文件资源，句柄等
        + 线程：程序计数器，寄存器，栈等
        + 协程：自己的寄存器上下文和栈
     6. **系统开销**
        + 进程：切换涉及到虚拟地址空间，内核栈与硬件上下文，开销较大
        + 线程：切换时只需保存和设置少量的寄存器内容，开销较小
        + 协程：直接操作栈则基本没有内核切换的开销，可以不加锁访问全局变量，所以上下文切换非常快
     7. **通信方面**
        + 进程：需要借助操作系统内核
        + 线程：线程间通信只需直接读写进程数据段，如全局变量来进行通信
        + 协程：共享内存，消息队列等

---

+  **介绍一下进程控制块PCB，及其中的内容**
   + 每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux内核的进程控制块是 task_struct结构体。
   + **PCB**内部重要成员
     1. 进程标识符
     2. 进程当前状态
     3. 进程优先级
     4. 进程资源清单
     5. 进程相应的程序和数据地址，以便把PCB与其程序和数据联系起来。
     6. 进程同步与通信机制等等

---

+ **你知道哪些进程？**

  + 孤儿进程：

    + 父进程已经终止的进程**,**它们的父进程都改变为**init**进程。这些进程自身变成孤儿进程，被init进程收养。

    > 由init进程收养的进程终止时不会成为僵尸进程。init被编写成无论何时只要有一个子进程终止，init就会调用 一个wait函数取得其终止状态。

  + 僵尸进程：

    + 一个已经终止、但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息、释放它仍占用的资源)的进程被称为僵死进程(zombie)，终止进程的残留资源(PCB)存放于内核中

    > 特别注意，僵尸进程是不能使用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止。
    >
    > + 如果父进程没有调用wait、waitpid，怎么杀死僵尸进程
    >   + 查看进程：ps -ef | grep defunct ： 1 running, 94 sleeping, 0 stopped, **0 zombie**
    >   + 一般僵尸进程很难直接kill掉，可以kill僵尸父进程。父进程死后，僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。
    >   + ps -e -o ppid,stat | grep Z | cut -d " " -f2 | xargs kill -9

  + 守护进程：

    + 是 Linux 的一种⻓期运行的后台服务进程 ，也称「精灵进程」。常⻅的 httpd、 named、sshd 等服务都是以守护进程 Daemon 方式运行的

---

+  **什么是惊群效应**
   + 惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），当等待的事件发生，它会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个事件的“控制权”，其他进程（线程）获取失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。
   + 现象的影响：
     + 这种效应使得系统对用户进程/线程频繁地做无效的调度，上下文切换，系统性能大打折扣。
     + 而且为了确保只有一个线程得到资源，用户必须对资源操作进行加锁保护，进一步加大了系统开销。
   + 例子：
     + Linux 2.6 之前。 主进程创建了socket、bind、listen之后，fork() 出来多个进程，每个子进程都开始循环处理（accept）这个listen_fd。 每个进程都阻塞在accept上，当一个新的连接到来时候，所有的进程都会被唤醒，但是其中只有一个进程会接受成功，其余皆失败，重新休眠。
     + Linux 2.6 之后的版本，Linux内核已经解决了accept（）函数的“惊群”现象，大概的处理方式就是，当内核接收到一个客户连接后，只会唤醒等待队列上的第一个进程（线程），所以如果服务器采用accept阻塞调用方式，在最新的linux系统中已经没有“惊群效应”了

---



### 死锁



---

## 八.数据库



---



## 九.网络编程相关

### 1.socket

- **TCP进行socket编程的步骤**

  - 服务端和客户端初始化 socket ，得到文件描述符;
  - 服务端调用 bind ，将绑定在 IP 地址和端口;
  - 服务端调用 listen ，进行监听;
  - 服务端调用 accept ，等待客户端连接；
  - 客户端调用 connect ，向服务器端的地址和端口发起连接请求;
  - 服务端 accept 返回用于传输的 socket 的文件描述符;
  - 客户端调用 write 写入数据;服务端调用 read 读取数据;
  - 客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ， 待处理完 数据后，
  - 服务端调用 close ，表示连接关闭。

- **服务器端会维护哪两个队列？** 

  - 未完成连接队列(SYN 队列):接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态; 
  - 已完成连接队列(Accpet 队列):已完成 TCP 三次握手过程，处于 ESTABLISHED 状态;

- **服务器端进行TCP连接(socket连接)时，内核的工作流程**

  - 当客户端发送的SYN请求报文到达后，插入到SYN 队列，随后给对方发送ACK确认报文
  - 当接收到客户端的ACK确认报文后，应用程序从Accpet 队列中取出已完成连接的socket

- **socket的各个步骤对应 TCP 握手中的哪些阶段？**

  - 客户端初始化 socket ，调用 connect 后，进入SYS-SENT状态，是第一次握手阶段
  - 服务器端初始化 socket ，调用 bind 绑定在 IP 地址和端口，调用 listen 进行监听后，进入Listen状态
  - 服务器端在接收到客户端的 SYN 请求报文后， 调用 accept ，等待客户端连接，并回复ACK确认报文，进入 SYN-RCVD状态
  - 客户端接收到ACK确认报文后，connect函数返回文件操作符，回复ACK确认报文，进入established状态
  - 服务器端收到对方的ACK确认报文后，accpet API 函数返回 文件操作符，进入established状态

- **为什么一个socket可以accept多次？**

  - 输入参数 fd 是从 socket， bind， listen 中沿用下来的 socket 句柄值，是在指定的端口处监昕所有的连接请求。
  - 调用 accept() 是从 socket fd 的请求队列抽取第一个连接信息，创建新的同类型 socket 句柄 fd 来进行后续操作。
  - 两个fd 是不同的，所以能 accept 多次

- **客户端调用close后，连接是断开的流程是什么?**

  - 就是四次挥手流程

- **IO有哪两种操作？**

  - 同步IO：必须等待 IO 操作完成后，控制权才返回给用户进程 。 
  - 异步IO：无须等待 IO 操作完成，就将控制权返回给用户进程 。 

- **网络IO发生时，设计哪些对象与操作？**

  - 会涉及两个系统对象：调用这个 IO 的 进程，系统内核。
  - 当一个 read操作发生时，会经历两个阶段:
    - 等待数据准备; 
    - 将数据从内核拷贝到进程中。

- **简单介绍一下4中IO模型。**

  - 阻塞IO：阻塞是指 IO 操作需要彻底完成后才返回到用户空间

    > 阻塞 IO 模型的特点就是：在 IO 执行的两个阶段(等待数据和拷贝数据)都被阻塞了 。

  - 非阻塞IO：非阻塞是指 IO 操作被调用后立即返回给用户一个状态值， 不需要等到 IO 操作彻底完成。

    > `fcntl( fd, F_SETFL, O_NONBLOCK );` 来设置socket成为非阻塞IO

  - 多路IO复用（事件驱动IO）：多路 IO复用 可以监视多个描述符， 一旦某个描述符就绪( 读就绪或写就绪)，能够通知程序进行相应的读写操作。 

    > 调用API后整个进程会被阻塞，而且存在两个系统调用(select与revcfrom)，如果连接数不多，不能体现优势。

  - 异步IO：

    - 用户角度：用户进程发起 read操作之后，立刻就可以开始去做其他的事;
    - 内核角度：当它收到一个异步的 read请求操作之后，首先会立刻返回，所以不会对用户进程产生任何阻塞。 然后，内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切完成后，内核会给用户进程发送一个信号，返回 read操作已完成的信息 。

  > + 阻塞 IO、非阻塞 IO 及多路 IO 复用都属于同步 IO。
  > + 非阻塞 IO在执行 recvfrom 候，若内核的数据没有准备好，不会阻塞进程 。 但当内核中数据准备好时， recvfrom 会将数据从内核拷贝到用户内存中，这时进程仍被阻塞。 
  > + 异步 IO 不同， 当进程发起 IO 操作之后，就直接返回，直到内核发送一个信号，告诉进程 IO 已完成，整个过程中进程完全没有被阻塞。

---

### 3.IO复用

- **介绍一下 select 系统调用设计的函数**

  ```c++
  #include <sys/select.h>
  void FD_ZERO(fd_set *set); 						//把文件描述符集合里所有位清0
  void FD_CLR(int fd, fd_set *set); 		//把文件描述符集合里fd清0
  int  FD_ISSET(int fd, fd_set *set); 	//测试文件描述符集合里fd是否置1
  void FD_SET(int fd, fd_set *set); 		//把文件描述符集合里fd位置1
  
  struct timeval {
    	long tv_sec; /* seconds */  
    	long tv_usec; /* microseconds */
  };
  
  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
             struct timeval *timeout);
  ```

  **参数：**

  + nfds： 指定被监听的文件描述符的总数。通常设置为被监听的所有fd中的最大值加1，因为fd从0开始计数的。

  + readfds：  监控有读数据到达文件描述符集合，传入传出参数

  + writefds： 监控写数据到达文件描述符集合，传入传出参数

  + exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数

  + timeout： 定时阻塞监控时间，3种情况

    1. NULL，永远等下去

    2. 设置timeval，等待固定时间

    3. 设置timeval里时间均为0，检查描述字后立即返回，轮询

  **返回值：**

  + 成功： **所监听的所有 监听集合中，满足条件的总数**
  + 失败： 返回 -1 并设置errno


---

+ **简单介绍一下select调用过程。**

  1. 在进行 `socket, bind, listen` 后，得到连接请求描述符 `listenfd`。设置数组`client[FD_SETSIZE]`存放文件描述符，全部初始化为 -1。

  2. 设置 存放文件描述符集合 `fd_set rset`，使用 `FD_ZERO(rset)` 进行清零，使用 `FD_SET(listenfd)` 将 `listenfd` 加入集合

  3. 设置 `maxfd = listenfd + 1` ，进行 while 循环，将 `rset` 赋给临时的` readset`，调用 `select` 函数

     > `select (maxfd, &readset,NULL, NULL, NULL)`

  4. 等待 `select` 有返回值时，得到就绪的文件操作符数目 `nready`，先进行判断是否合理，然后利用 `FD_ISSET(listenfd, &rset)`  判断是否有新的连接

  5. 如果有，则调用 `accept` ，返回连接后的文件描述符 `connfd` 。使用 `FD_SET(connfd, &readset); ` 将 `connfd` 放入 `readset` 集合中。

  6. 遍历 `client` 数组，将 `connfd` 放入合适位置，`nready--` 。最后更新 `maxfd`

  7. 随后遍历 client 数组，找出其中的 文件描述符， 使用 `FD_ISSET(sockfd, &rset)` 操作，判断是否存在读事件，如果是，则继续进行任务操作，如 read。  `nready--` 。

  8. 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。 

---

+ **介绍一下 poll 系统调用函数**

  ```c
  #include <poll.h>
  
  struct pollfd {
      int fd; /* 文件描述符 */
  		short events; /* 监控的事件：主要是 POLLIN,POLLOUT,POLLERR */
  		short revents; /* 监控事件中满足条件返回的事件，由内核填充 */
  };
  
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  ```

  **参数：**

  + fds： pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读，可写和异常等事件。
  + nfds： 指定被监听时间集合fds的大小。
  + timeout： 毫秒级等待
    + -1：阻塞等待，#define INFTIM -1         Linux中没有定义此宏
    + = 0：立即返回，不阻塞进程
    + \> 0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值

  **返回值：**

  + 成功： 所监听的所有 监听集合中，满足条件的总数
  + 失败： 返回 -1 并设置errno

---

+ **简单介绍一下poll调用过程。**

  + 定义 pollfd 结构体数组 `struct pollfd client[1024]`，将第一个`client[0]`设置fd与events设置为listenfd与POLLIN，其余fd为-1 ，设置maxi = 1。

  + 进行循环，调用 poll 函数， 返回就绪文件描述符个数，查看`client[0]`是否为 POLLIN事件(`client[0].revents & POLLIN`) 

    > `nready = poll(client, maxi, -1);`

  + 如果是，调用accept得到新的连接文件描述符connfd，将其存放到client数组中合适的位置。更新maxi,nready--。

  + 遍历前面`1-maxi`个client数组，找出就绪的文件描述符，查看是否为POLLIN事件，如果事，则进行下面的任务处理，nready--。

  + 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。

---

+ **介绍一下 epoll 系统调用函数**

  + epoll_create 函数：创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数

    ```c++
    #include <sys/epoll.h>
    
    int epoll_create(int size);
    ```

    + 参数：
      + size：监听数目(告诉Linux内核创建多大的epoll模型)，创建多大结点的红黑树，只是建议值，
    + 返回值：
      + 成功返回 文件描述符，指向红黑树的根
      + 失败返回 -1

  + epoll_ctl 函数：控制某个epoll监控的文件描述符上的事件：注册、修改、删除。

    ```c++
     #include <sys/epoll.h>
    
    struct epoll_event {
    			__uint32_t events; /* Epoll events */
    			epoll_data_t data; /* User data variable */
    };
    
    typedef union epoll_data {
        void *ptr;
        int fd;					//与epoll_ctl函数中的fd对应
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;
    
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    /*
    	epoll_event中的 events:
    	EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
    	EPOLLOUT：	表示对应的文件描述符可以写
    	EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
    	EPOLLERR：	表示对应的文件描述符发生错误
    	EPOLLHUP：	表示对应的文件描述符被挂断；
    	EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
    	EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
    */
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根
      + op ： 在红黑树树上进心增删改：
        + EPOLL_CTL_ADD (注册新的fd到epfd)
        + EPOLL_CTL_MOD (修改已经注册的fd的监听事件)
        + EPOLL_CTL_DEL (从epfd删除一个fd)
      + fd ： 具体需要操作的文件描述符
      + event： 告诉内核需要监听的事件(往往只需要 events 与 data.fd)
    + 返回值：
      + 成功返回 0
      + 失败返回 -1

  + epoll_wait函数： 等待所监控文件描述符上有事件的产生，类似于 select() 调用。

    ```c++
    #include <sys/epoll.h>
    
    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    ```

    + 参数：

      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根

      + events ： 是一个传出参数数组

        > epoll_ctl中是传入变量的地址，这个变量初始化好就行
        >
        > epoll_wait中是传入数组，传出满足事件的文件描述符，每个元素都是epoll_event结构体

      + maxevents ： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，

      + timeout ：是超时时间

        +  -1： 阻塞
        +  0： 立即返回，非阻塞
        +  \>0： 指定毫秒

    + 返回值：

      + 成功返回有多少文件描述符就绪
      + 时间到时返回0，
      + 出错返回-1

---

+ **简单介绍一下 epoll 的调用过程**

  1. 通过 `epoll_create` 函数创建 epoll 模型，返回红黑树的根结点作为文件描述符 efd。

  2. 创建epoll_event事件与数组(`struct epoll_event tep, ep[OPEN_MAX]; `)，将tep的event设置为EPOLLIN，data.fd 设置为 listenfd。利用 epoll_ctl 函数将 listen 与 tep 添加到 efd 的红黑树中

     >  `res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep); `

  3. 循环，将 数组 ep 代入epoll_wait函数等待文件描述符就绪，当就绪后，返回就绪的文件描述符数目

     > ` nready = epoll_wait(efd, ep, OPEN_MAX, -1); ` 

  4. 循环 ep 数组中前 nready 个元素，查看是否是EPOLLIN事件(`ep[i].events & EPOLLIN`) 

  5. 如果是，则查看是否为listenfd 就绪(`ep[i].data.fd == listenfd`)，如果是，则调用accpet函数，返回新的连接文件描述符 connfd，重新赋值给 tep ，利用 epoll_ctl 函数将tep 加入红黑树中

  6. 如果不是listenfd 就绪，则取出，赋值给sockef，利用它来完成其他任务操作。

---

+ **介绍一下 epoll 的两种触发模式**

  + **Level Triggered (LT 水平触发)** ：epoll的默认触发方式，既支持阻塞模式，也支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。一次性读写完未全部完成，那么下次调用 epoll_wait()时，还会通知在上次没读写完的文件描述符上继续读写

  + **Edge Triggered (ET 边缘触发)** ： 只支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。一次性全部读写完未完成，那么下次调用epoll_wait()时，不会通知，即只会通知一次，直到该文件描述符上出现第二次可读写事件。

    > 最好是利用边缘触发，使用非阻塞fd，套上while循环将数据一次性读写完成，这样效率更高。

---

+  **在ET模式下当多个连接同时到达时该怎么处理？**

   + 理论上如果多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。

   + 解决办法是用while循环包住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。

---

+  **nigix的实现中多个连接同时到达如何处理？**
   + nigix 中 ，accept函数调用使用水平触发的fd，就是出于对丢失连接的考虑，所以不存在丢失连接的问题。
   + 但是若系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，会大大降低处理程序检索自己关心的就绪文件描述符的效率。

---

+ **使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？**
  + 平时不要把该描述符放进event_poll结构体中，当需要写该fd的时候，调用epoll_ctl把fd加入eventpoll里监听，可写的时候就往里写，写完再次调用epoll_ctl把fd移出event_poll，这种方法在发送很少数据的时候仍要执行两次epoll_ctl操作，有一定的操作代价
  + 改进一下就是：平时不要把该描述符放进event_poll结构体中，需要写的时候调用write或者send写数据，如果返回值是EAGAIN（写缓冲区满了），那么这时候才执行第一种方法的步骤。

---

+ **比较IO复用 select，poll，epoll 的区别**

  + select、 poll和 epoll都是多路 IO 复用机制。 可以监视多个描述符， 一旦某个描述符就绪，会通知程序进行相应的读写操作。 但它们本质上都是同步 IO，因为它们都需要在读写事件就绪后自己负责进行读写，是阻塞的。

  + select的优缺点：

    + select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。
    + select()对于超时值提供了更好的精度，而 poll()是精度较差。
    + select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024
    + select采用的是轮询模型，如果链接客户端过多，会大大降低服务器响应效率

  + poll的优缺点：

    + 可以修改文件描述符的上限数目，优于select
    + 将监听集合 和 返回集合 实现了分离，不像select那么麻烦，搜索范围更小
    + poll在应付大数目的文件描述符时速度更快，对于 select 来说内核需要检查大量描述符对应的set中的每一个比特位，比较费时。
    + 但还是需要将数组全部变量，找出已连接的文件描述符，而不是直接返回满足的文件描述符数组。

  + epoll 的优点

    + 支持ET触发模式，其余两者只支持LT。

    + 不是使用轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；selet 与 poll 调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。

    + 使用 mmap加速内核与用户空间的消息传递

      > 3者都需要内核把fd消息通知给用户空间，如何避免不必要的内存拷贝就显得尤为重要 。 
      >
      > epoll 通过内核 与用户空间 mmap 处于同一块内存实现的 。
      >
      > poll将传入的 pollfd数组拷贝到内核空间，因为拷贝操作和数组长度相关，时间上来看，这是一个 O(n)操作

---

+ Libevent如何处理IO事件，信号事件，和定时事件








---

## 十一.Redis 









---

## 十二.WebServer项目相关

+  介绍一下你的WebServer项目
+  线程池的优点是什么？

+  项目里实现了哪些HTTP请求呢，处理的时候如何分辨这些请求呢？
+  设想这样一种场景，我的web服务器里面有一张表格，现在浏览器需要请求这个表格中 id=张三 的内容，同时返回到浏览器也需要以表格的形式展现。

---

## 十三.智力题

+ 智力题 楼层丢鸡蛋
+ 8个赛道，64匹马，要选前4，需要多少轮。
+ 一个检测试剂10分钟检测一位病人，工厂有1000人，最少多少支试剂能10分钟内检测出来哪一位患病？讲出原理（小猪喝水问题的变种
+ 1-100，报号，每次剔除奇数位置的人，问这样剔除以后最后剩下的是几号？64







---

## 综合面试

+ 自我介绍，将自己的经历和项目做一些介绍； 
+ 自己所做邻域的国内外现状、学术界和工业界的状况（因为我研究生期间做的内容比较小众）； 
+ 应聘季自己应聘的优势和劣势； 
+ 对华为的文化怎么理解； 
+ 自己最喜欢的学习方式； 
+ 将来的职业规划；