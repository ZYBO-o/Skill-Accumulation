## 刷题

### 面试问过的

+ 给定一个数组num和两个数字L和R，数组长度为n，问你这个数组里面有多少个连续的子数组，满足这个子数组中的最大值大于等于L，小于等于R。
+ 给一个字符串，输出最长连续子串。
+ n的所有最小因数集合，如8，其最小质数集合为{1,2,2,2}
+ 手撕 unique_pointer
+ [个人博客 - 设计parser](https://xyfu.me/posts/de9ec62b/)
+ 布隆过滤器
+ hash表解决冲突的方法
+ 红黑树性质
+ redis中的数据结构
+ 跳表插入删除过程
+ 判断大小端，int的大端转小端
+ 去掉字符串开头和末尾的空格
+ 大数相加
+ 最长公共子序列LCS
+ 最小编辑距离
+ 二叉树中两个节点的最近公共父节点
+ 数据流的中位数
+ [算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题)是两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组，找中位数。我回答了lc上的O(log M +N )的最优解方法
+  40E个数，找出唯一不存在的数？进行(内存)优化？大数据问题都是用[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)进行分组，每一组做一次遍历，就可以大大减少内存占用
+ 1~N，其中有两个数重复，找出重复的数？
+ 写个单例模式的例子
+ 设计题，快速找出所有微信关系里的单向好友
+ 一个字符串ajxnhdbdosjbsorange,模式“o*ge”,找到匹配的最小字符串下标范围。
+ hashfunc一般怎么实现(除法散列，乘法散列 等等)
+ hashmap发生冲突怎么解决([链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)法、开放寻址法等等)
+ 1亿个数怎么找中位数(哈希分组，然后快排寻找)
+ 一个字符串，比如abc123/f/ecd,连续的数字或者连续的字母，或者反斜杠后和后面一个字符，视为一个整体，反转之。比如这时输出应该是cd/e/f123abc.(一开始用了栈来做，非常简单。然后面试官问有没有其他方法，我就说一个先分段反转再整体反转的原地做法。
+ 开放寻址法要如何查找一个元素
+ 一个无序数组,如何寻找第n大的数(BFPTR[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法))
+ 单向[链表]()中如何高效删除一个结点（只给定头指针和指向当前结点的指针）  
+ 给定n个正整数，如何找出最小的K个正整数 
+ 给定一组整数1000以内，如何高效去除重复的数
+ 字符串中查找是否有子串，写完以后要求给出测试用例

### 链表

+  **从尾到头打印链表**
  + 反转链表；打印后反转；使用栈
+  **链表中倒数最后k个结点**
  + 双指针：一个先行，一个后行
+   **反转链表**
  +  双指针： 不停反转，直到链尾
+  **合并两个有序链表**
  + 双指针：
+  **复杂链表的复制**
  + 双指针
+   **两个链表的第一个公共结点**
  +  双指针：设置 p1,p2分别指向各自链表进行前行，遇到链尾时指向对方链头，知道双方结点相同。
+   **链表中环的入口结点**
  + 双指针：设置快慢指针fast,slow，相遇表示有环；设置指针p指向head，p与slow相遇，则是入环结点。

+   **删除链表中重复的结点**
  +  双指针：



##  C++

+ 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？
+ 虚函数的作用及实现原理
+ 局部变量、全局变量、常量还有malloc开辟的内存变量分别放在哪个区
+ 全局变量的初始化位置
+ 游戏中，有些资源文件需要频繁使用，如何进行加速  
+ 游戏中，如果有一个AOE的BUFF（类似皇子的旗子E技能），如何实时快速计算这些技能的影响单位 

---

### C相关问题

+  **C程序如何启动和终止的**
  + 内核调用一个exec函数，调用exec的进程将命令行参数传递给启动例程，然后启动例程调用main函数。
  + 进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用\_exit或 \_Exit。进程也可非自愿地由一个信号使其终止。

+  **atexit函数**
  + atexit函数类似于C++类中的析构函数，在main函数结束之后被exit调用，调用顺序与登记顺序相反。同一函数如若登记多次也会被调用多次。
  + `atexit`的参数是一个函数地址，无需传递参数,也不期望返回值。

+  **C程序的存储地址空间布局**
  + 从低地址往高地址分别为： 正文段—> 初始化数据段—> 未初始化数据段—> 堆——>栈。
  + 它们的主要作用：
    + 正文段：这部分是共享的，也是只读的，是CPU执行的机器指令部分。
    + 初始化数据段：包含程序中需明确地赋初值的变量
    + 未初始化数据段：也称为bss段( block started by symbol)，在程序执行之前，内核将该段中的数据初始化为0或空指针。
    + 堆：动态分配存储的区域
    + 栈：自动变量以及函数调用所需要保存信息的区域

+  **什么是共享库，有什么优点**
  + 库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。共享库可以让它的代码同时为多个进程所用，而代码实例在整个内存空间中仅需一份。
  + 优点：
    + 程序调用动态库函数时，用动态链接方法将程序与共享库函数相链接。缩少了可执行文件的大小。
    + 新版本代替老版本时，无需对使用该库的程序重新连接编译。
+  **讲一下存储空间分配函数——malloc, realloc, calloc各自的用法**
  + `void *malloc(size_t size);`  分配指定字节数的存储区，初始值不确定
  + `void *calloc(size_t nobj, size_t size);` 分配指定 数目，长度 的存储空间， 初始化为0
  + `void *realloc(void *ptr, size_t newsize);` 增加或减少以前分配区的长度，新增区初始值不确定
+   **C++ 中的 string 与 C 中的 `char *` 有什么区别？**
  + string继承自 basic_string ，是对 `char` 进行了封装，包含 char 数组，容量，长度等属性
  + string可以动态扩展，每次扩展是原空间的两倍，将原内容拷贝进去。

### C++基本介绍

---

+  struct和union的区别
+ 介绍auto,主要是会覆盖顶层的引用和修饰。
+ 如果要保留顶层的引用和修饰要用什么？decltype
+  什么是字节对齐
+ 知道虚函数表指针在内存中是怎么分布的吗？(我直接按照Lippman那本书回答)。
+ 虚函数表指针放在头部和尾部的好处分别是什么？(自己挖的坑。。)

---

+ 聊一聊C++面向对象的三大特性

  > C++ 的三大特性就是继承，封装和多态。

  + 继承：让某种类型对象获得另一个类型对象的属性和方法。有三种继承方式：
    + 实现继承：指使用基类的属性和方法而无需额外编码的能力
    + 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    + 可视继承：(C++里好像不怎么用)
  + 封装：变量和方法捆绑成类，可以对它们进行信息隐藏，只让可信的对象和类操作。
  + 多态：同一事物表现出不同事物的能力。实现多态的两种方式：
    + 覆盖： 是指子类重新定义父类的虚函数的做法。
    + 重载：是指允许存在多个同名函数，而函数的参数表不同

### 变量与基本类型

---

+  **变量与定义的区别**
  + 声明仅仅将变量声明的位置与类型提供给编译器，并不分配内存。定义会在定义的地方直接分配存储空间。
  + 相同变量可在多处声明，但只能一处定义。
+  **什么情况下必须用到初始化成员列表**
  + 初始化const成员
  + 初始化reference成员
  + 调用基类的构造函数，该函数有参数
  + 调用数据成员对象的构造函数，该函数有参数
+  **常量指针与指针常量的区别**
  + 常量指针指常量的指针，注重常量，不能修改指定的值 ：`int const *p` 或 `const int *p`
  + 指针常量指不能修改指针的指向，指针是一个常量： `int *const p` 。
+  **介绍野指针与空悬指针，如何避免？**
  + 野指针：没有初始化的指针
  + 空悬指针： 指针最初指向的内存已经被释放了的一种指针。
  + 解决方法：使用完置空，或者使用智能指针。

## STL

+ 手写string类







## 计算机网络

+ 计算机网络体系为什么要按照现有体系进行分层
+ 服务器出现大量Time-wait状态的原因及解决方法 ，出现大量Close-wait状态的原因及解决方法

---

### 1.网络层





### 2.TCP层

+ TCP如何实现可靠传输
  + TCP序列号
+ 那TCP如何用序列号来保证可靠传输
  + 介绍了下 握手时交换initial sequence number、ACK、超时重传 和 快速重传
+ 讲讲TCP KeepAlive(保活机制,即心跳包)
+ 为什么喜欢在应用层定义KeepAlive而不用TCP协议栈中自带的？(我回答更灵活,可以自定义配置比如消息类型，时间间隔，接收后的处理)

+  **TCP连接建立过程中要解决哪些问题？**

+  **TCP链接建立过程**

+  **TCP建立连接中维护「序列号」的作用？**

  + 接收方可以去除重复的数据; 
  + 接收方可以根据数据包的序列号按序接收; 
  + 可以标识发送出去的数据包中， 哪些是已经被对方收到的

+  **TCP建立连接为什么是三次握手，而不是两次或四次？**

  + TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。
  + 不使用「两次握手」和「四次握手」的原因:
    + 「两次握手」:无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号; 
    + 「四次握手」:三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

+   **为什么客户端和服务端的初始序列号 ISN 是不相同的**

  + 如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱
  + 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。

+  **初始序列号 ISN 是如何随机产生的?**

  + ISN = M + F (localhost, localport, remotehost, remoteport)

    > + M 是一个计时器，这个计时器每隔 4 毫秒加 1。
    > + F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

+  **既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢?**

  > +  **MTU :** 一个网络包的最大⻓度，以太网中一般为 1500 字节;
  > +  **MSS :** 除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度;

  + 将 TCP 的整个报文(头部 + 数据)交给 IP 层进行分片的话，如果一个 **IP** 分片丢失，整个 **IP** 报文的所有分片都得重传。 因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。
  + 当接收方发现 TCP 报文(头部 + 数据)的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时 后，就重会发「整个 TCP 报文(头部 + 数据)」。非常没有效率。
  + 为了达到最佳的传输效能， TCP 协议在建立连接的时候通常要协商双方的 **MSS** 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 **MSS** 为单位，而不用传所有 的分片，大大增加了重传的效率。

+  **什么是SYN攻击？**
  + 因为 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到 一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 **SYN** 接收队列(未连接队列)，使得服务器不能为正常用户服务。

+  **如何避免SYN攻击？**
  + 修改 Linux 内核参数，控制队列大小和当队列满时应做相应的处理。
    + 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。超出处理能时，对新的 SYN 直接回报 RST，丢弃连接。
    + tcp_syncookies 的方式可以应对 SYN 攻击的方法: net.ipv4.tcp_syncookies = 1

+ **TCP链接释放的过程**

+  **释放连接为什么需要四次挥手？**
  + 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
  + 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
  + 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。
  
+   **MSL 与 TTL 的区别是什么？**

   +  MSL 是 Maximum Segment Lifetime，表示任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃。
   +  因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，表示经过的最大路由数，每经过一个路由器就减 1，为 0 则被丢弃，同时发送 ICMP 报文通知源主机。
   +  MSL 的单位是时间，而 TTL 是经过路由跳数。往往 **MSL** 应该要大于等于 **TTL** 消耗为 **0** 的 时间，以确保报文已被自然消亡。

+   **为什么需要 TIME_WAIT 状态?**

   +  防止旧连接的数据包，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

   +  保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；

      > 若客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSED 状态了，那么服务端则会一直处在 LASE_ACK 状态。

+  **为什么 TIME_WAIT 等待的时间是 2MSL?**
  +  网络中可能存在来自发送方的数据包，当这些数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 **2** 倍的时间。
  + 在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。**Linux** 系统停留在 **TIME_WAIT** 的时 间为固定的 **60** 秒。

+  **TIME_WAIT 过多有什么危害?**
  + 客户端TIME_WAIT过多，就会导致端口资源被占用，被占满就会导致无法创建新的连接。
  + 服务端只监听一个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。

---

### 3.HTTP层

+ HTTP和HTTPS有哪些不同的地方呢？ARP协议的作用，哪些过程会使用这个协议呢？在一个广域网中，我如何利用该协议来找到目标主机的MAC地址并返回给源主机呢？(大概是这么问的吧，回答的时候我也说了一下IP协议)



+ HTTP状态码

---

## 操作系统

### Linux 命令

+ linux 中查看监听网络端口命令，more和cat的区别



+ linux 改密码命令 改权限命令

 

+  如何结束一个进程， -9 是什么含义



+ ps的底层实现(我按照自己的理解，讲了一下PCB的机制，然后说大概是扫描了一下PCB的[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)，面试官好像挺满意的)。

+ 对于大文件，为什么CP比MV慢很多
+ 如果rm以及rm -f一个正在被使用的文件，会发生什么

### 进程与线程

+ 两个进程会存放在相同的内存地址吗？讲几种进程调度的算法？进程的状态有哪几种？哪些操作会使进程从用户态到内核态呢？

+ Linux进程地址空间分布
+ Linux内存管理方法，页面置换[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，逻辑地址和物理地址的转换
+ 解释孤儿进程，僵死进程，惊群效应
+ 生产-消费者模型，伪代码，用条件变量，注意使用while()替代if()判断是否满足条件
+ C++20里的协程，所以又问了我协程相关的东西，包括内核线程和用户态线程之类的。
+ 为什么要区分内核和用户态
+ linux怎么管理进程内存？
+ 怎么快速定位linux下占用资源很大的程序单元
+  哪些时候会发生上下文切换，上下文切换过程中经历了什么
+ 如果父进程没有调用wait、waitpid，怎么杀死僵尸进程

### 死锁

+ 死锁的四个必要条件



+ 举例子讲解如何解决死锁



---

## 数据库



+ truncate 和delete区别



+ 索引分类和原理----B+树，具体分析



+ 数据库锁有哪些，造成原因



+ 如果在数据库上进行了误操作该怎么处理



+ 数据库sga问题



+ B树和B+树的区别，ACID, 索引种类，explain关键字



+ 介绍一下数据库索引(B+树、哈希索引、LSM树之类)



+ 索引的类别和使用场景
+  Mysql如何实现主从一致性



---

## 调试

### gdb







## 链接与编译





## 网络编程相关

+ 讲讲非阻塞socket
+ 文件读经历了哪些过程

---



### 1.socket

-  **TCP进行socket编程的步骤**
  - 服务端和客户端初始化 socket ，得到文件描述符;
  - 服务端调用 bind ，将绑定在 IP 地址和端口;
  - 服务端调用 listen ，进行监听;
  - 服务端调用 accept ，等待客户端连接；
  - 客户端调用 connect ，向服务器端的地址和端口发起连接请求;
  - 服务端 accept 返回用于传输的 socket 的文件描述符;
  - 客户端调用 write 写入数据;服务端调用 read 读取数据;
  - 客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ， 待处理完 数据后，
  - 服务端调用 close ，表示连接关闭。

-  **服务器端会维护哪两个队列？** 
  - 未完成连接队列(SYN 队列):接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态; 
  - 已完成连接队列(Accpet 队列):已完成 TCP 三次握手过程，处于 ESTABLISHED 状态;

-  **服务器端进行TCP连接(socket连接)时，内核的工作流程**
  - 当客户端发送的SYN请求报文到达后，插入到SYN 队列，随后给对方发送ACK确认报文
  - 当接收到客户端的ACK确认报文后，应用程序从Accpet 队列中取出已完成连接的socket

-  **socket的各个步骤对应 TCP 握手中的哪些阶段？**

  - 客户端初始化 socket ，调用 connect 后，进入SYS-SENT状态，是第一次握手阶段
  - 服务器端初始化 socket ，调用 bind 绑定在 IP 地址和端口，调用 listen 进行监听后，进入Listen状态
  - 服务器端在接收到客户端的 SYN 请求报文后， 调用 accept ，等待客户端连接，并回复ACK确认报文，进入 SYN-RCVD状态
  - 客户端接收到ACK确认报文后，connect函数返回文件操作符，回复ACK确认报文，进入established状态
  - 服务器端收到对方的ACK确认报文后，accpet API 函数返回 文件操作符，进入established状态

-  **为什么一个socket可以accept多次？**

  - 输入参数 fd 是从 socket， bind， listen 中沿用下来的 socket 句柄值，是在指定的端口处监昕所有的连接请求。
  - 调用 accept() 是从 socket fd 的请求队列抽取第一个连接信息，创建新的同类型 socket 句柄 fd 来进行后续操作。
  - 两个fd 是不同的，所以能 accept 多次

-  **客户端调用close后，连接是断开的流程是什么?**

  - 就是四次挥手流程

-  **IO有哪两种操作？**

  - 同步IO：必须等待 IO 操作完成后，控制权才返回给用户进程 。 
  - 异步IO：无须等待 IO 操作完成，就将控制权返回给用户进程 。 

-   **网络IO发生时，设计哪些对象与操作？**

  - 会涉及两个系统对象：调用这个 IO 的 进程，系统内核。
  - 当一个 read操作发生时，会经历两个阶段:
    - 等待数据准备; 
    - 将数据从内核拷贝到进程中。

-  **简单介绍一下4中IO模型。**

  - 阻塞IO：阻塞是指 IO 操作需要彻底完成后才返回到用户空间

    > 阻塞 IO 模型的特点就是：在 IO 执行的两个阶段(等待数据和拷贝数据)都被阻塞了 。

  - 非阻塞IO：非阻塞是指 IO 操作被调用后立即返回给用户一个状态值， 不需要等到 IO 操作彻底完成。

    > `fcntl( fd, F_SETFL, O_NONBLOCK );` 来设置socket成为非阻塞IO

  - 多路IO复用（事件驱动IO）：多路 IO复用 可以监视多个描述符， 一旦某个描述符就绪( 读就绪或写就绪)，能够通知程序进行相应的读写操作。 

    > 调用API后整个进程会被阻塞，而且存在两个系统调用(select与revcfrom)，如果连接数不多，不能体现优势。

  - 异步IO：

    - 用户角度：用户进程发起 read操作之后，立刻就可以开始去做其他的事;
    - 内核角度：当它收到一个异步的 read请求操作之后，首先会立刻返回，所以不会对用户进程产生任何阻塞。 然后，内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切完成后，内核会给用户进程发送一个信号，返回 read操作已完成的信息 。

  > + 阻塞 IO、非阻塞 IO 及多路 IO 复用都属于同步 IO。
  > + 非阻塞 IO在执行 recvfrom 候，若内核的数据没有准备好，不会阻塞进程 。 但当内核中数据准备好时， recvfrom 会将数据从内核拷贝到用户内存中，这时进程仍被阻塞。 
  > + 异步 IO 不同， 当进程发起 IO 操作之后，就直接返回，直到内核发送一个信号，告诉进程 IO 已完成，整个过程中进程完全没有被阻塞。

---

### 3.IO复用

-  **介绍一下 select 系统调用设计的函数**

  ```c++
  #include <sys/select.h>
  void FD_ZERO(fd_set *set); 						//把文件描述符集合里所有位清0
  void FD_CLR(int fd, fd_set *set); 		//把文件描述符集合里fd清0
  int  FD_ISSET(int fd, fd_set *set); 	//测试文件描述符集合里fd是否置1
  void FD_SET(int fd, fd_set *set); 		//把文件描述符集合里fd位置1
  
  struct timeval {
    	long tv_sec; /* seconds */  
    	long tv_usec; /* microseconds */
  };
  
  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
             struct timeval *timeout);
  ```

  **参数：**

  + nfds： 指定被监听的文件描述符的总数。通常设置为被监听的所有fd中的最大值加1，因为fd从0开始计数的。

  + readfds：  监控有读数据到达文件描述符集合，传入传出参数

  + writefds： 监控写数据到达文件描述符集合，传入传出参数

  + exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数

  + timeout： 定时阻塞监控时间，3种情况

    1. NULL，永远等下去

    2. 设置timeval，等待固定时间

    3. 设置timeval里时间均为0，检查描述字后立即返回，轮询

  **返回值：**

  + 成功： **所监听的所有 监听集合中，满足条件的总数**
  + 失败： 返回 -1 并设置errno


---

+  **简单介绍一下select调用过程。**

  1. 在进行 `socket, bind, listen` 后，得到连接请求描述符 `listenfd`。设置数组`client[FD_SETSIZE]`存放文件描述符，全部初始化为 -1。

  2. 设置 存放文件描述符集合 `fd_set rset`，使用 `FD_ZERO(rset)` 进行清零，使用 `FD_SET(listenfd)` 将 `listenfd` 加入集合

  3. 设置 `maxfd = listenfd + 1` ，进行 while 循环，将 `rset` 赋给临时的` readset`，调用 `select` 函数

     > `select (maxfd, &readset,NULL, NULL, NULL)`

  4. 等待 `select` 有返回值时，得到就绪的文件操作符数目 `nready`，先进行判断是否合理，然后利用 `FD_ISSET(listenfd, &rset)`  判断是否有新的连接
  5. 如果有，则调用 `accept` ，返回连接后的文件描述符 `connfd` 。使用 `FD_SET(connfd, &readset); ` 将 `connfd` 放入 `readset` 集合中。
  6. 遍历 `client` 数组，将 `connfd` 放入合适位置，`nready--` 。最后更新 `maxfd`
  7. 随后遍历 client 数组，找出其中的 文件描述符， 使用 `FD_ISSET(sockfd, &rset)` 操作，判断是否存在读事件，如果是，则继续进行任务操作，如 read。  `nready--` 。
  8. 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。 

---

+  **介绍一下 poll 系统调用函数**

  ```c
  #include <poll.h>
  
  struct pollfd {
      int fd; /* 文件描述符 */
  		short events; /* 监控的事件：主要是 POLLIN,POLLOUT,POLLERR */
  		short revents; /* 监控事件中满足条件返回的事件，由内核填充 */
  };
  
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  ```

  **参数：**

  + fds： pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读，可写和异常等事件。
  + nfds： 指定被监听时间集合fds的大小。
  + timeout： 毫秒级等待
    + -1：阻塞等待，#define INFTIM -1         Linux中没有定义此宏
    + = 0：立即返回，不阻塞进程
    + \> 0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值

  **返回值：**

  + 成功： 所监听的所有 监听集合中，满足条件的总数
  + 失败： 返回 -1 并设置errno

---

+  **简单介绍一下poll调用过程。**

  + 定义 pollfd 结构体数组 `struct pollfd client[1024]`，将第一个`client[0]`设置fd与events设置为listenfd与POLLIN，其余fd为-1 ，设置maxi = 1。

  + 进行循环，调用 poll 函数， 返回就绪文件描述符个数，查看`client[0]`是否为 POLLIN事件(`client[0].revents & POLLIN`) 

    > `nready = poll(client, maxi, -1);`

  + 如果是，调用accept得到新的连接文件描述符connfd，将其存放到client数组中合适的位置。更新maxi,nready--。

  + 遍历前面`1-maxi`个client数组，找出就绪的文件描述符，查看是否为POLLIN事件，如果事，则进行下面的任务处理，nready--。

  + 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。

---

+ **介绍一下 epoll 系统调用函数**

  + epoll_create 函数：创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数

    ```c++
    #include <sys/epoll.h>
    
    int epoll_create(int size);
    ```

    + 参数：
      + size：监听数目(告诉Linux内核创建多大的epoll模型)，创建多大结点的红黑树，只是建议值，
    + 返回值：
      + 成功返回 文件描述符，指向红黑树的根
      + 失败返回 -1

  + epoll_ctl 函数：控制某个epoll监控的文件描述符上的事件：注册、修改、删除。

    ```c++
     #include <sys/epoll.h>
    
    struct epoll_event {
    			__uint32_t events; /* Epoll events */
    			epoll_data_t data; /* User data variable */
    };
    
    typedef union epoll_data {
        void *ptr;
        int fd;					//与epoll_ctl函数中的fd对应
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;
    
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    /*
    	epoll_event中的 events:
    	EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
    	EPOLLOUT：	表示对应的文件描述符可以写
    	EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
    	EPOLLERR：	表示对应的文件描述符发生错误
    	EPOLLHUP：	表示对应的文件描述符被挂断；
    	EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
    	EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
    */
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根
      + op ： 在红黑树树上进心增删改：
        + EPOLL_CTL_ADD (注册新的fd到epfd)
        + EPOLL_CTL_MOD (修改已经注册的fd的监听事件)
        + EPOLL_CTL_DEL (从epfd删除一个fd)
      + fd ： 具体需要操作的文件描述符
      + event： 告诉内核需要监听的事件(往往只需要 events 与 data.fd)
    + 返回值：
      + 成功返回 0
      + 失败返回 -1

  + epoll_wait函数： 等待所监控文件描述符上有事件的产生，类似于 select() 调用。

    ```c++
    #include <sys/epoll.h>
    
    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根

      + events ： 是一个传出参数数组

        > epoll_ctl中是传入变量的地址，这个变量初始化好就行
        >
        > epoll_wait中是传入数组，传出满足事件的文件描述符，每个元素都是epoll_event结构体

      + maxevents ： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，

      + timeout ：是超时时间

        +  -1： 阻塞
        +  0： 立即返回，非阻塞
        +  \>0： 指定毫秒

    + 返回值：
      + 成功返回有多少文件描述符就绪
      + 时间到时返回0，
      + 出错返回-1

---

+  **简单介绍一下 epoll 的调用过程**

  1. 通过 `epoll_create` 函数创建 epoll 模型，返回红黑树的根结点作为文件描述符 efd。

  2. 创建epoll_event事件与数组(`struct epoll_event tep, ep[OPEN_MAX]; `)，将tep的event设置为EPOLLIN，data.fd 设置为 listenfd。利用 epoll_ctl 函数将 listen 与 tep 添加到 efd 的红黑树中

     >  `res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep); `

  3. 循环，将 数组 ep 代入epoll_wait函数等待文件描述符就绪，当就绪后，返回就绪的文件描述符数目

     > ` nready = epoll_wait(efd, ep, OPEN_MAX, -1); ` 

  4. 循环 ep 数组中前 nready 个元素，查看是否是EPOLLIN事件(`ep[i].events & EPOLLIN`) 

  5. 如果是，则查看是否为listenfd 就绪(`ep[i].data.fd == listenfd`)，如果是，则调用accpet函数，返回新的连接文件描述符 connfd，重新赋值给 tep ，利用 epoll_ctl 函数将tep 加入红黑树中

  6. 如果不是listenfd 就绪，则取出，赋值给sockef，利用它来完成其他任务操作。

---

+ **介绍一下 epoll 的两种触发模式**

  + **Level Triggered (LT 水平触发)** ：epoll的默认触发方式，既支持阻塞模式，也支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。一次性读写完未全部完成，那么下次调用 epoll_wait()时，还会通知在上次没读写完的文件描述符上继续读写

  + **Edge Triggered (ET 边缘触发)** ： 只支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。一次性全部读写完未完成，那么下次调用epoll_wait()时，不会通知，即只会通知一次，直到该文件描述符上出现第二次可读写事件。

    > 最好是利用边缘触发，使用非阻塞fd，套上while循环将数据一次性读写完成，这样效率更高。

---

+  **在ET模式下当多个连接同时到达时该怎么处理？**

  + 理论上如果多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。

  + 解决办法是用while循环包住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。

---

+  **nigix的实现中多个连接同时到达如何处理？**
  + nigix 中 ，accept函数调用使用水平触发的fd，就是出于对丢失连接的考虑，所以不存在丢失连接的问题。
  + 但是若系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，会大大降低处理程序检索自己关心的就绪文件描述符的效率。

---

+ **使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？**
  + 平时不要把该描述符放进event_poll结构体中，当需要写该fd的时候，调用epoll_ctl把fd加入eventpoll里监听，可写的时候就往里写，写完再次调用epoll_ctl把fd移出event_poll，这种方法在发送很少数据的时候仍要执行两次epoll_ctl操作，有一定的操作代价
  + 改进一下就是：平时不要把该描述符放进event_poll结构体中，需要写的时候调用write或者send写数据，如果返回值是EAGAIN（写缓冲区满了），那么这时候才执行第一种方法的步骤。

---

+ **比较IO复用 select，poll，epoll 的区别**

  + select、 poll和 epoll都是多路 IO 复用机制。 可以监视多个描述符， 一旦某个描述符就绪，会通知程序进行相应的读写操作。 但它们本质上都是同步 IO，因为它们都需要在读写事件就绪后自己负责进行读写，是阻塞的。

  + select的优缺点：

    + select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。
    + select()对于超时值提供了更好的精度，而 poll()是精度较差。
    + select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024
    + select采用的是轮询模型，如果链接客户端过多，会大大降低服务器响应效率

  + poll的优缺点：

    + 可以修改文件描述符的上限数目，优于select
    + 将监听集合 和 返回集合 实现了分离，不像select那么麻烦，搜索范围更小
    + poll在应付大数目的文件描述符时速度更快，对于 select 来说内核需要检查大量描述符对应的set中的每一个比特位，比较费时。
    + 但还是需要将数组全部变量，找出已连接的文件描述符，而不是直接返回满足的文件描述符数组。

  + epoll 的优点

    + 支持ET触发模式，其余两者只支持LT。

    + 不是使用轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；selet 与 poll 调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。

    + 使用 mmap加速内核与用户空间的消息传递

      > 3者都需要内核把fd消息通知给用户空间，如何避免不必要的内存拷贝就显得尤为重要 。 
      >
      > epoll 通过内核 与用户空间 mmap 处于同一块内存实现的 。
      >
      > poll将传入的 pollfd数组拷贝到内核空间，因为拷贝操作和数组长度相关，时间上来看，这是一个 O(n)操作

---

+ Libevent如何处理IO事件，信号事件，和定时事件

  

## WebServer项目相关

+  **介绍一下你的WebServer项目**
  + 这是一个服务器项目
+  **线程池的优点是什么？**
  + 线程池旨在降低创建和销毁线程的频率，使其维持合理数量的线程，并让空闲的线程重新承担新的任务 。
  + 连接池是指维持连接的缓存池，尽量重用已有的连接，降低创建和关闭连接的频率。
  + 这两种技术能降低系统开销，但当请求数目远远大于池中元素的数目时，没有显著的效果。特别是在阻塞IO下。

+ 项目里实现了哪些HTTP请求呢，处理的时候如何分辨这些请求呢？
+ 设想这样一种场景，我的web服务器里面有一张表格，现在浏览器需要请求这个表格中 id=张三 的内容，同时返回到浏览器也需要以表格的形式展现。

---

## 综合面试

+ 智力题 楼层丢鸡蛋
+ 8个赛道，64匹马，要选前4，需要多少轮。
+ 一个检测试剂10分钟检测一位病人，工厂有1000人，最少多少支试剂能10分钟内检测出来哪一位患病？讲出原理（小猪喝水问题的变种
+ 1-100，报号，每次剔除奇数位置的人，问这样剔除以后最后剩下的是几号？64
+ 自我介绍，将自己的经历和项目做一些介绍； 
+ 自己所做邻域的国内外现状、学术界和工业界的状况（因为我研究生期间做的内容比较小众）； 
+ 应聘季自己应聘的优势和劣势； 
+ 对华为的文化怎么理解； 
+ 自己最喜欢的学习方式； 
+ 将来的职业规划；