##  C++









## STL









## 计算机网络

### 1.网络层





### 2.TCP层



+  **TCP连接建立过程中要解决哪些问题？**

+  **TCP链接建立过程**

+  **TCP建立连接中维护「序列号」的作用？**

  + 接收方可以去除重复的数据; 
  + 接收方可以根据数据包的序列号按序接收; 
  + 可以标识发送出去的数据包中， 哪些是已经被对方收到的

+  **TCP建立连接为什么是三次握手，而不是两次或四次？**

  + TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。
  + 不使用「两次握手」和「四次握手」的原因:
    + 「两次握手」:无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号; 
    + 「四次握手」:三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

+   **为什么客户端和服务端的初始序列号 ISN 是不相同的**

  + 如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱
  + 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。

+  **初始序列号 ISN 是如何随机产生的?**

  + ISN = M + F (localhost, localport, remotehost, remoteport)

    > + M 是一个计时器，这个计时器每隔 4 毫秒加 1。
    > + F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

+  **既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢?**

  > +  **MTU :** 一个网络包的最大⻓度，以太网中一般为 1500 字节;
  > +  **MSS :** 除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度;

  + 将 TCP 的整个报文(头部 + 数据)交给 IP 层进行分片的话，如果一个 **IP** 分片丢失，整个 **IP** 报文的所有分片都得重传。 因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。
  + 当接收方发现 TCP 报文(头部 + 数据)的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时 后，就重会发「整个 TCP 报文(头部 + 数据)」。非常没有效率。
  + 为了达到最佳的传输效能， TCP 协议在建立连接的时候通常要协商双方的 **MSS** 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 **MSS** 为单位，而不用传所有 的分片，大大增加了重传的效率。

+  **什么是SYN攻击？**
  + 因为 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到 一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 **SYN** 接收队列(未连接队列)，使得服务器不能为正常用户服务。

+  **如何避免SYN攻击？**
  + 修改 Linux 内核参数，控制队列大小和当队列满时应做相应的处理。
    + 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。超出处理能时，对新的 SYN 直接回报 RST，丢弃连接。
    + tcp_syncookies 的方式可以应对 SYN 攻击的方法: net.ipv4.tcp_syncookies = 1

+  **TCP链接释放的过程**
+  **释放连接为什么需要四次挥手？**
  + 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
  + 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等 、服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
  + 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。