##  C++

### C相关问题

+  **C程序如何启动和终止的**
  + 内核调用一个exec函数，调用exec的进程将命令行参数传递给启动例程，然后启动例程调用main函数。
  + 进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用\_exit或 \_Exit。进程也可非自愿地由一个信号使其终止。

+  **atexit函数**
  + atexit函数类似于C++类中的析构函数，在main函数结束之后被exit调用，调用顺序与登记顺序相反。同一函数如若登记多次也会被调用多次。
  + `atexit`的参数是一个函数地址，无需传递参数,也不期望返回值。

+  **C程序的存储地址空间布局**
  + 从低地址往高地址分别为： 正文段—> 初始化数据段—> 未初始化数据段—> 堆——>栈。
  + 它们的主要作用：
    + 正文段：这部分是共享的，也是只读的，是CPU执行的机器指令部分。
    + 初始化数据段：包含程序中需明确地赋初值的变量
    + 未初始化数据段：也称为bss段( block started by symbol)，在程序执行之前，内核将该段中的数据初始化为0或空指针。
    + 堆：动态分配存储的区域
    + 栈：自动变量以及函数调用所需要保存信息的区域

+  **什么是共享库，有什么优点**
  + 库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。共享库可以让它的代码同时为多个进程所用，而代码实例在整个内存空间中仅需一份。
  + 优点：
    + 程序调用动态库函数时，用动态链接方法将程序与共享库函数相链接。缩少了可执行文件的大小。
    + 新版本代替老版本时，无需对使用该库的程序重新连接编译。
+  **讲一下存储空间分配函数——malloc, realloc, calloc各自的用法**
  + `void *malloc(size_t size);`  分配指定字节数的存储区，初始值不确定
  + `void *calloc(size_t nobj, size_t size);` 分配指定 数目，长度 的存储空间， 初始化为0
  + `void *realloc(void *ptr, size_t newsize);` 增加或减少以前分配区的长度，新增区初始值不确定
+   **C++ 中的 string 与 C 中的 `char *` 有什么区别？**
  + string继承自 basic_string ，是对 `char` 进行了封装，包含 char 数组，容量，长度等属性
  + string可以动态扩展，每次扩展是原空间的两倍，将原内容拷贝进去。

### C++基本介绍

+ 聊一聊C++面向对象的三大特性

  > C++ 的三大特性就是继承，封装和多态。

  + 继承：让某种类型对象获得另一个类型对象的属性和方法。有三种继承方式：
    + 实现继承：指使用基类的属性和方法而无需额外编码的能力
    + 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    + 可视继承：(C++里好像不怎么用)
  + 封装：变量和方法捆绑成类，可以对它们进行信息隐藏，只让可信的对象和类操作。
  + 多态：同一事物表现出不同事物的能力。实现多态的两种方式：
    + 覆盖： 是指子类重新定义父类的虚函数的做法。
    + 重载：是指允许存在多个同名函数，而函数的参数表不同

### 变量与基本类型

+  **变量与定义的区别**
  + 声明仅仅将变量声明的位置与类型提供给编译器，并不分配内存。定义会在定义的地方直接分配存储空间。
  + 相同变量可在多处声明，但只能一处定义。
+  **什么情况下必须用到初始化成员列表**
  + 初始化const成员
  + 初始化reference成员
  + 调用基类的构造函数，该函数有参数
  + 调用数据成员对象的构造函数，该函数有参数
+  **常量指针与指针常量的区别**
  + 常量指针指常量的指针，注重常量，不能修改指定的值 ：`int const *p` 或 `const int *p`
  + 指针常量指不能修改指针的指向，指针是一个常量： `int *const p` 。
+  **介绍野指针与空悬指针，如何避免？**
  + 野指针：没有初始化的指针
  + 空悬指针： 指针最初指向的内存已经被释放了的一种指针。
  + 解决方法：使用完置空，或者使用智能指针。

## STL









## 计算机网络

### 1.网络层





### 2.TCP层



+  **TCP连接建立过程中要解决哪些问题？**

+  **TCP链接建立过程**

+  **TCP建立连接中维护「序列号」的作用？**

  + 接收方可以去除重复的数据; 
  + 接收方可以根据数据包的序列号按序接收; 
  + 可以标识发送出去的数据包中， 哪些是已经被对方收到的

+  **TCP建立连接为什么是三次握手，而不是两次或四次？**

  + TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。
  + 不使用「两次握手」和「四次握手」的原因:
    + 「两次握手」:无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号; 
    + 「四次握手」:三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

+   **为什么客户端和服务端的初始序列号 ISN 是不相同的**

  + 如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱
  + 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。

+  **初始序列号 ISN 是如何随机产生的?**

  + ISN = M + F (localhost, localport, remotehost, remoteport)

    > + M 是一个计时器，这个计时器每隔 4 毫秒加 1。
    > + F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

+  **既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢?**

  > +  **MTU :** 一个网络包的最大⻓度，以太网中一般为 1500 字节;
  > +  **MSS :** 除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度;

  + 将 TCP 的整个报文(头部 + 数据)交给 IP 层进行分片的话，如果一个 **IP** 分片丢失，整个 **IP** 报文的所有分片都得重传。 因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。
  + 当接收方发现 TCP 报文(头部 + 数据)的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时 后，就重会发「整个 TCP 报文(头部 + 数据)」。非常没有效率。
  + 为了达到最佳的传输效能， TCP 协议在建立连接的时候通常要协商双方的 **MSS** 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 **MSS** 为单位，而不用传所有 的分片，大大增加了重传的效率。

+  **什么是SYN攻击？**
  + 因为 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到 一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 **SYN** 接收队列(未连接队列)，使得服务器不能为正常用户服务。

+  **如何避免SYN攻击？**
  + 修改 Linux 内核参数，控制队列大小和当队列满时应做相应的处理。
    + 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。超出处理能时，对新的 SYN 直接回报 RST，丢弃连接。
    + tcp_syncookies 的方式可以应对 SYN 攻击的方法: net.ipv4.tcp_syncookies = 1

+  **TCP链接释放的过程**
+  **释放连接为什么需要四次挥手？**
  + 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
  + 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等 、服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
  + 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。