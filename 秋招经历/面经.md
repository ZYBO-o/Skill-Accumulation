## **刷题**

### 面试问过的

+ 给定一个数组num和两个数字L和R，数组长度为n，问你这个数组里面有多少个连续的子数组，满足这个子数组中的最大值大于等于L，小于等于R。
+ 给一个字符串，输出最长连续子串。
+ n的所有最小因数集合，如8，其最小质数集合为{1,2,2,2}
+ 手撕 unique_pointer
+ [个人博客 - 设计parser](https://xyfu.me/posts/de9ec62b/)
+ 布隆过滤器
+ hash表解决冲突的方法
+ 红黑树性质
+ redis中的数据结构
+ 跳表插入删除过程
+ 判断大小端，int的大端转小端
+ 去掉字符串开头和末尾的空格
+ 大数相加
+ 最长公共子序列LCS
+ 最小编辑距离
+ 二叉树中两个节点的最近公共父节点
+ 数据流的中位数
+ [算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题)是两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组，找中位数。我回答了lc上的O(log M +N )的最优解方法
+  40E个数，找出唯一不存在的数？进行(内存)优化？大数据问题都是用[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)进行分组，每一组做一次遍历，就可以大大减少内存占用
+ 1~N，其中有两个数重复，找出重复的数？
+ 写个单例模式的例子
+ 设计题，快速找出所有微信关系里的单向好友
+ 一个字符串ajxnhdbdosjbsorange,模式“o*ge”,找到匹配的最小字符串下标范围。
+ hashfunc一般怎么实现(除法散列，乘法散列 等等)
+ hashmap发生冲突怎么解决([链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)法、开放寻址法等等)
+ 1亿个数怎么找中位数(哈希分组，然后快排寻找)
+ 一个字符串，比如abc123/f/ecd,连续的数字或者连续的字母，或者反斜杠后和后面一个字符，视为一个整体，反转之。比如这时输出应该是cd/e/f123abc.(一开始用了栈来做，非常简单。然后面试官问有没有其他方法，我就说一个先分段反转再整体反转的原地做法。
+ 开放寻址法要如何查找一个元素
+ 一个无序数组,如何寻找第n大的数(BFPTR[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法))
+ 单向[链表]()中如何高效删除一个结点（只给定头指针和指向当前结点的指针）  
+ 给定n个正整数，如何找出最小的K个正整数 
+ 给定一组整数1000以内，如何高效去除重复的数
+ 字符串中查找是否有子串，写完以后要求给出测试用例

### 链表

+  **从尾到头打印链表**
  + 反转链表；打印后反转；使用栈
+  **链表中倒数最后k个结点**
  + 双指针：一个先行，一个后行
+   **反转链表**
  +  双指针： 不停反转，直到链尾
+  **合并两个有序链表**
  + 双指针：
+  **复杂链表的复制**
  + 双指针
+   **两个链表的第一个公共结点**
  +  双指针：设置 p1,p2分别指向各自链表进行前行，遇到链尾时指向对方链头，知道双方结点相同。
+   **链表中环的入口结点**
  + 双指针：设置快慢指针fast,slow，相遇表示有环；设置指针p指向head，p与slow相遇，则是入环结点。

+   **删除链表中重复的结点**
  +  双指针：



##  C++

+ 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？
+ 虚函数的作用及实现原理
+ 局部变量、全局变量、常量还有malloc开辟的内存变量分别放在哪个区
+ 全局变量的初始化位置
+ 游戏中，有些资源文件需要频繁使用，如何进行加速  
+ 游戏中，如果有一个AOE的BUFF（类似皇子的旗子E技能），如何实时快速计算这些技能的影响单位 

---

### C相关问题

+  **C程序如何启动和终止的**
  + 内核调用一个exec函数，调用exec的进程将命令行参数传递给启动例程，然后启动例程调用main函数。
  + 进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用\_exit或 \_Exit。进程也可非自愿地由一个信号使其终止。

+  **atexit函数**
  + atexit函数类似于C++类中的析构函数，在main函数结束之后被exit调用，调用顺序与登记顺序相反。同一函数如若登记多次也会被调用多次。
  + `atexit`的参数是一个函数地址，无需传递参数,也不期望返回值。

+  **C程序的存储地址空间布局**
  + 从低地址往高地址分别为： 正文段—> 初始化数据段—> 未初始化数据段—> 堆——>栈。
  + 它们的主要作用：
    + 正文段：这部分是共享的，也是只读的，是CPU执行的机器指令部分。
    + 初始化数据段：包含程序中需明确地赋初值的变量
    + 未初始化数据段：也称为bss段( block started by symbol)，在程序执行之前，内核将该段中的数据初始化为0或空指针。
    + 堆：动态分配存储的区域
    + 栈：自动变量以及函数调用所需要保存信息的区域

+  **什么是共享库，有什么优点**
  + 库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。共享库可以让它的代码同时为多个进程所用，而代码实例在整个内存空间中仅需一份。
  + 优点：
    + 程序调用动态库函数时，用动态链接方法将程序与共享库函数相链接。缩少了可执行文件的大小。
    + 新版本代替老版本时，无需对使用该库的程序重新连接编译。
+  **讲一下存储空间分配函数——malloc, realloc, calloc各自的用法**
  + `void *malloc(size_t size);`  分配指定字节数的存储区，初始值不确定
  + `void *calloc(size_t nobj, size_t size);` 分配指定 数目，长度 的存储空间， 初始化为0
  + `void *realloc(void *ptr, size_t newsize);` 增加或减少以前分配区的长度，新增区初始值不确定
+   **C++ 中的 string 与 C 中的 `char *` 有什么区别？**
  + string继承自 basic_string ，是对 `char` 进行了封装，包含 char 数组，容量，长度等属性
  + string可以动态扩展，每次扩展是原空间的两倍，将原内容拷贝进去。

### C++基本介绍

---

+  struct和union的区别
+ 介绍auto,主要是会覆盖顶层的引用和修饰。
+ 如果要保留顶层的引用和修饰要用什么？decltype
+  什么是字节对齐
+ 知道虚函数表指针在内存中是怎么分布的吗？(我直接按照Lippman那本书回答)。
+ 虚函数表指针放在头部和尾部的好处分别是什么？(自己挖的坑。。)

---

+ 聊一聊C++面向对象的三大特性

  > C++ 的三大特性就是继承，封装和多态。

  + 继承：让某种类型对象获得另一个类型对象的属性和方法。有三种继承方式：
    + 实现继承：指使用基类的属性和方法而无需额外编码的能力
    + 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
    + 可视继承：(C++里好像不怎么用)
  + 封装：变量和方法捆绑成类，可以对它们进行信息隐藏，只让可信的对象和类操作。
  + 多态：同一事物表现出不同事物的能力。实现多态的两种方式：
    + 覆盖： 是指子类重新定义父类的虚函数的做法。
    + 重载：是指允许存在多个同名函数，而函数的参数表不同

### 变量与基本类型

---

+  **变量与定义的区别**
  + 声明仅仅将变量声明的位置与类型提供给编译器，并不分配内存。定义会在定义的地方直接分配存储空间。
  + 相同变量可在多处声明，但只能一处定义。
+  **什么情况下必须用到初始化成员列表**
  + 初始化const成员
  + 初始化reference成员
  + 调用基类的构造函数，该函数有参数
  + 调用数据成员对象的构造函数，该函数有参数
+  **常量指针与指针常量的区别**
  + 常量指针指常量的指针，注重常量，不能修改指定的值 ：`int const *p` 或 `const int *p`
  + 指针常量指不能修改指针的指向，指针是一个常量： `int *const p` 。
+  **介绍野指针与空悬指针，如何避免？**
  + 野指针：没有初始化的指针
  + 空悬指针： 指针最初指向的内存已经被释放了的一种指针。
  + 解决方法：使用完置空，或者使用智能指针。

## STL

+ 手写string类







## 计算机网络

+ 计算机网络体系为什么要按照现有体系进行分层
+ 服务器出现大量Time-wait状态的原因及解决方法 ，出现大量Close-wait状态的原因及解决方法

---

### 1.网络层





### 2.TCP层

+ TCP如何实现可靠传输
  + TCP序列号
+ 那TCP如何用序列号来保证可靠传输
  + 介绍了下 握手时交换initial sequence number、ACK、超时重传 和 快速重传
+ 讲讲TCP KeepAlive(保活机制,即心跳包)
+ 为什么喜欢在应用层定义KeepAlive而不用TCP协议栈中自带的？(我回答更灵活,可以自定义配置比如消息类型，时间间隔，接收后的处理)

---

+ **传输层的工作内容是什么？**
  + 从通信和信息处理的角度看，运输层向上面的应用层提供通信的服务，属于面向通信部分的最高层，也是用户功能部分的最底层。(只有网络边缘部分的主机协议栈才有运输层)

---

+  **网络层与传输层的区别？**
  + 网络层是为主机之间提供逻辑通信
  + 传输层为应用进程之间提供端到端的逻辑通信

---

+  **运输层有什么重要功能？**
  + 主机中实现多个应用进程分别与另一台主机中的多个应用进程通信，拥有复用与分用的能力
    + 复用： 发送方不同应用进程都能使用同一个运输层协议传输数据（加上适当的首部）
    + 分用： 接收方的运输层在剥去报文的首部后，能把数据正确的交付给对应的目的进程

---

+  **在运输层中端口有什么作用？**
  + 从运输层的角度看，通信的对象是进程，而端口就代表了进程。
    + 端口用一个16位端口号进行标记
    + 只需有本地意义，只标记了本计算机应用层的各个进程

---

+  **用户数据报协议UDP(User Datagram Protocol) 有什么特点？**

  1. 面向报文的，对应用层交付的报文，不合并也不拆分，加上首部之后直接发送

     > + 报文太长，交给IP层之后，IP层可能会分片，降低IP层效率
     > + 报文太短，交给IP层之后，显得IP数据报首部相对长度太长，也降低IP层效率

  2. 无连接的：发送消息之前不需要建立连接，减少了开销与发送数据之前的延迟
  3. 尽最大努力交付：不保证可靠交付，因此主机之间不需要维持复杂的连接状态表
  4. 没有拥塞控制：因此网络拥塞时不会使源主机的发送速率降低，符合多媒体通信要求
  5. 支持一对一，一对多，多对一，多对多的交互通信
  6. 首部开销小，只有8字节，比TCP的20字节小

---

+  **介绍一下UDP的首部格式**
  + UDP有两个字段：  首部字段 和 数据字段。首部字段有8个字节，由4个字段组成，每个字段占两个字节：
    + 源端口： 源端口号。需要给对方回信时使用，不用时赋予0
    + 目的端口： 目的端口号。 在终点交付报文时必须使用
    + 长度：UDP数据报的长度，最小值为8
    + 检验和：检验UDP 数据报在传输过程中是否出错，出错则丢弃

---

+  **为什么需要TCP协议？**
  + IP层是不可靠，不保证网络包的按需交付与数据完整性。
  + 如果需要保证传输过程可靠，则需要上层的TCP协议来负责，TCP能保证接收端收到的网络包是按序，无损坏的

---

+  **介绍一下 传输控制协议TCP(Transmission Control Protocol)，它有什么特点？**

  + TCP是面向连接的运输层协议，在无连接，不可靠的IP层网络服务基础上提供 **可靠交付** 的 **基于字节流** 的传输层通信协议

    + 面向连接： TCP连接只支持点对点的，只有两个端点

    + 可靠的：传输过程中无论网络链路怎么变化，TCP第一能保证报文能达到接收端

    + 面向字节流： 虽然应用程序与TCP以数据块的形式交互，但TCP把上层交付下来的数据仅看成是一连串无结构的字节流

      > TCP 不保证接收方应用程序数据块与发出的数据块大小对应，但字节流必须完全一样。

  + 传输过程的特点：

    + TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文⻓ 度是应用进程给出的）
    + TCP 可把太⻓的数据块划分短一些再传送
    + TCP 也可等待积累有足够多的字节后再构成报文段发送出去

---

+  **TCP报文段首部有哪些字段？**
  + 从前往后分别是
    + 源端口号 (2 bytes)，目的端口号 (2 bytes)
    + 序号  (4 bytes)
    + 确认号  (4 bytes)
    + 数据偏移， 保留，紧急URG，确认ACK，推送PSH，复位RST，同步SYN，终止FIN，窗口 (2 bytes)
    + 检验和  (2 bytes)，紧急指针 (2 bytes)
    + 选项字段 ，填充(首部是4字节的整数倍)

---

+  **介绍一下TCP的连接的端点与协商内容**

  + TCP面向的是套接字，连接端点称为socket或者插口

    <div align  = center>socket = ip地址 + 端口号 </div>

  + 建立TCP连接时需要通信两端达成三个信息的共识

    + socket：即IP地址与端口号
    + 序列号：用来解决乱序问题
    + 窗口大小：用作流量控制

---

+  **如何确定一个TCP连接**
  + 源地址，源端口，目的地址，目的端口，这四元组能确定一个连接
    + 源地址，目的地址 在IP头部，通过IP协议将报文发送到具体主机
    + 源端口，目的端口 在TCP头部，通过TCP协议将报文发送到具体进程

---

+  **有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？**

  + 最大TCP连接数 = 客户端 IP 数 * 客户端的端口数

  + 对 IPv4， IP 数最多为 $2^{32}$ ，端口数最多为$2^{16}$，则最大 TCP连接数为 $2^{48}$。但远不能到达这个上限值。

    > + 文件描述符限制，Socket 都是文件，要通过 ulimit 配置文件描述符的数目;
    > + 内存限制

---

+ **TCP与UDP有哪些区别？**
  1. 连接：
     +  TCP面向连接传输协议，传输数据之前需建立连接，UDP无连接，即可传输
  2. 服务对象
     + TCP点对点
     + UDP都行
  3. 传输方式
     + TCP 面向连接，基于字节流，无边界，但保证有序与可靠
     + UDP直接发送包，有边界，但可能出现丢包与乱序
  4. 可靠性
     + TCP是可靠交付数据，有序，不丢失，无损伤
     + UDP尽最大努力传输，不保证可靠性
  5. 拥塞控制，流量控制
     + TCP有拥塞控制与流量控制机制，保证数据传输的安全性
     + UDP没有，就算网络拥堵也不影响发送速率
  6. 首部开销
     + TCP首部较长，没有使用选项字段时为20字节，开销较大
     + UDP首部只有8字节，固定不变，开销较小
  7. 分片方法
     + TCP是在传输层进行分片，当数据大于MSS，TCP会进行分片，若中途丢失一个分片，只需重发对应分片即可
     + UDP是在网络层进行分片，当数据大于MTU，IP会进行分片，若中途丢失一个分片，在实现可靠传输的 UDP 时需重传整个的数据包，所以通常UDP报文应该小于MTU
  8. 应用场景
     + TCP是可靠交付，用于
       + FTP文件传输
       + HTTP/HTTPS
     + UDP 无连接，可随时发送，处理简单高效
       + 包总量较小的通信，如DNS，SNMP
       + 视频，音频等多媒体通信
       + 广播通信

---

+  **为什么UDP头部没有 首部长度 字段，而TCP有？**
  + TCP有可变长的 选项 字段，所以需要记录长度
  + UDP首部大小固定，无需记录

---

+  **为什么 UDP 头部有「包⻓度」字段，而 TCP 头部则没有「包⻓度」字段呢?**
  + TCP 是计算负载数据⻓度:  TCP数据的⻓度 =  IP总⻓度 - IP首部⻓度 - IP首部⻓度
  + UDP其实也可以这么计算，但可能是为了网络设备硬件设计和处理方便，首部⻓度需 **4** 字节整数倍。利用字段可能可能是为了补全。

---

+ **TCP连接建立过程中要解决哪些问题？**
+ **TCP链接建立过程**

---

+  **TCP建立连接中维护「序列号」的作用？**

  + 接收方可以去除重复的数据; 
  + 接收方可以根据数据包的序列号按序接收; 
  + 可以标识发送出去的数据包中， 哪些是已经被对方收到的

---

+  **TCP建立连接为什么是三次握手，而不是两次或四次？**

  + TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序 列号。序列号能够保证数据包不重复、不丢弃和按序传输。
  + 不使用「两次握手」和「四次握手」的原因:
    + 「两次握手」:无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号; 
    + 「四次握手」:三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

---

+   **为什么客户端和服务端的初始序列号 ISN 是不相同的**

  + 如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，则会产生数据错乱
  + 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收。

---

+  **初始序列号 ISN 是如何随机产生的?**

  + ISN = M + F (localhost, localport, remotehost, remoteport)

    > + M 是一个计时器，这个计时器每隔 4 毫秒加 1。
    > + F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

---

+  **既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢?**

  > +  **MTU :** 一个网络包的最大⻓度，以太网中一般为 1500 字节;
  > +  **MSS :** 除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度;

  + 将 TCP 的整个报文(头部 + 数据)交给 IP 层进行分片的话，如果一个 **IP** 分片丢失，整个 **IP** 报文的所有分片都得重传。 因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。
  + 当接收方发现 TCP 报文(头部 + 数据)的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时 后，就重会发「整个 TCP 报文(头部 + 数据)」。非常没有效率。
  + 为了达到最佳的传输效能， TCP 协议在建立连接的时候通常要协商双方的 **MSS** 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 **MSS** 为单位，而不用传所有 的分片，大大增加了重传的效率。

---

+  **什么是SYN攻击？**
  + 因为 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到 一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 **SYN** 接收队列(未连接队列)，使得服务器不能为正常用户服务。

---

+  **如何避免SYN攻击？**
  + 修改 Linux 内核参数，控制队列大小和当队列满时应做相应的处理。
    + 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。超出处理能时，对新的 SYN 直接回报 RST，丢弃连接。
    + tcp_syncookies 的方式可以应对 SYN 攻击的方法: net.ipv4.tcp_syncookies = 1

---

+ **TCP链接释放的过程**
+  **释放连接为什么需要四次挥手？**
  + 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
  + 服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。
  + 从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

---

+   **MSL 与 TTL 的区别是什么？**

   +  MSL 是 Maximum Segment Lifetime，表示任何报文在网络上存在的最⻓时间，超过这个时间报文将被丢弃。
   +  因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，表示经过的最大路由数，每经过一个路由器就减 1，为 0 则被丢弃，同时发送 ICMP 报文通知源主机。
   +  MSL 的单位是时间，而 TTL 是经过路由跳数。往往 **MSL** 应该要大于等于 **TTL** 消耗为 **0** 的 时间，以确保报文已被自然消亡。

---

+   **为什么需要 TIME_WAIT 状态?**

   +  防止旧连接的数据包，经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。

   +  保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；

      > 若客户端四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSED 状态了，那么服务端则会一直处在 LASE_ACK 状态。

---

+  **为什么 TIME_WAIT 等待的时间是 2MSL?**
  +  网络中可能存在来自发送方的数据包，当这些数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 **2** 倍的时间。
  + 在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。**Linux** 系统停留在 **TIME_WAIT** 的时 间为固定的 **60** 秒。

---

+  **TIME_WAIT 过多有什么危害?**
  + 客户端TIME_WAIT过多，就会导致端口资源被占用，被占满就会导致无法创建新的连接。
  + 服务端只监听一个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。

---

+  **TCP如何实现的可靠传输？** 
  + 首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。
  + 其次，TCP采用了连续ARQ协议来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。
  + 最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。

---

+  **介绍一下停止等待协议**
  + **“**停止等待**”**就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
  + 发送方如何知道对方正确收到消息的？
    + 每一个已发送的分组都设置了一个超时计时器。 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 ，否则重发
  + 如何知道收到 了重复的分组，需要丢弃呢？
    + 每一个发送的分组都进行编号。接收方收到了编号相同的分组，则认为收到了重复分组，会进行丢弃，并回送确认
    + 发送方也为发送的确认也进行编号，指示该确认是对哪一个分组的确认。
    + 接收方根据确认其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。
  + 改进：为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。

---

+  **介绍一下 连续ARQ协议**
  + 发送方设置
    + 发送方设置发送窗口，将发送窗口中的分组连续发送出去，而不用等待对方的确认，提高了信道利用率
    + 发送方没接收到一个确认，就会把发送窗口向前滑动一个分组的位置
  + 接收方设置
    + 不需要对每一个分组逐个发送确认，只需对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都已正确收到。
  + 回退N机制：如果发送方发送了前 5 个分组，而中间的第 **3** 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 
  + 优点：容易实现，即使确认丢失也不必重传
  + 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

---

+  **介绍一下TCP的流量控制方法**
  + TCP利用滑动窗口实现流量控制。窗口用来暂时存放字节流。发送方和接收方各有一个窗口。接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
  + 发送方：发送窗口内的字节都允许被发送，窗口左部的字节已经发送并且收到了确认，就将窗口右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态。
  + 接收方：接收窗口内的字节都允许被接收，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。接收窗口只会对窗口内最后一个按序到达的字节进行确认。

---

+  **介绍一下TCP的拥塞控制原理**

  + 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。否则导致网络拥塞程度更高，重发分组数目也会更多

  + TCP 主要通过四个算法来进行拥塞控制: 慢开始、拥塞避免、快重传、快恢复。

  + 发送方需要维护一个叫做拥塞窗口(cwnd)的状态变量

    >  拥塞窗口 与 发送方窗口 的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

  + **慢开始与拥塞避免**

    + 发送的最初执行慢开始，令 cwnd = 1，只能发送 1 个报文段；当收到确认后，将 cwnd 加倍
    + 设置一个慢开始⻔限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1
    + 如果出现了**==超时==**，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

  + 快重传与快恢复

    + 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已接收到 M1，M2，此时收到 M4，应当发送对 M2 的确认。 
    + 在发送方，如果收到三个重复确认，则知道下一个报文段丢失，应执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
    + 在这种情况下，只是**==丢失==**个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

  > 区分好 两者的区别和使用场景。

---

### 3.HTTP层

+ HTTP和HTTPS有哪些不同的地方呢？ARP协议的作用，哪些过程会使用这个协议呢？在一个广域网中，我如何利用该协议来找到目标主机的MAC地址并返回给源主机呢？(大概是这么问的吧，回答的时候我也说了一下IP协议)



+ HTTP状态码



---

+ **键入网址到网⻚显示，期间发生了什么?**
  1. 查询**DNS**，获取域名对应的**IP**。
     + 检查本地hosts文件是否有这个网址的映射，如果有，就调用这个IP地址映射，解析完成。
     + 如果没有，则查找本地DNS解析器缓存
     + 如果没有，查找填写或分配的首选DNS服务器，称为本地DNS服务器。
     + 则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则 继续向上请求。最终将解析结果依次返回本地DNS服务器，本地DNS服务器再返回给客户机，查询完成。
  2. 客户端与服务器建立**TCP**连接(三次握手)
  3. 客户机发送**HTTP**请求报文:
     + 应用层:客户端发送HTTP请求报文
     + 传输层:切分⻓数据，并确保可靠性。
     + 网络层:进行路由
     + 数据链路层:传输数据
     + 物理层:物理传输bit 
  4. 经过物理层→数据链路层→网络层→传输层→应用层到达服务器端，服务器解析请求报文，发送HTTP响应报文。 
  5. 客户端收到后解析HTTP响应报文
  6. 浏览器开始显示HTML 
  7. 浏览器重新发送请求获取图片、CSS、JS的数据。

---

+  **Linux系统是如何收发网络包的？**
  + 发送流程：
    + 首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层 协议的类型， 比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。
    +  到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机 后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。
    + 传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据拷 ⻉到 Socket 的接收缓冲区。
    + 最后，应用层程序调用 Socket 接口，从内核的 Socket 接收缓冲区读取新到来的数据到应用层。 至此，一个网络包的接收过程 就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。
  + 接收流程：
    + 首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，Socket 层会将应用层数据拷⻉到 Socket 发送缓冲区中。
    + 接下来，网络协议栈从 Socket 发送缓冲区中取出数据包，并按照 TCP/IP 协议栈从上到下逐层处理。 如果使用的是 TCP 传输协 议发送数据，那么会在传输层增加 TCP 包头，然后交给网络层，网络层会给数据包增加 IP 包，然后通过查询路由表确认下一跳的 IP，并按照 MTU 大小进行分片。 分片后的网络包，就会被送到网络接口层，在这里会 通过 ARP 协议获得下一跳的 MAC 地址，然后增加帧头和帧尾，放到发包队列中。
    +  这一些准备好后，会触发软中断告诉网卡驱动程序，这里有新的网络包需要发送，最后驱动程序通过 DMA，从发 包队列中读取 网络包，将其放入到硬件网卡的队列中，随后物理网卡再将它发送出去。

---

## 操作系统

### Linux 命令

+ linux 中查看监听网络端口命令，more和cat的区别



+ linux 改密码命令 改权限命令

 

+  如何结束一个进程， -9 是什么含义



+ ps的底层实现(我按照自己的理解，讲了一下PCB的机制，然后说大概是扫描了一下PCB的[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)，面试官好像挺满意的)。

+ 对于大文件，为什么CP比MV慢很多
+ 如果rm以及rm -f一个正在被使用的文件，会发生什么

### 进程与线程

+ 两个进程会存放在相同的内存地址吗？讲几种进程调度的算法？进程的状态有哪几种？哪些操作会使进程从用户态到内核态呢？

+ Linux进程地址空间分布
+ Linux内存管理方法，页面置换[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，逻辑地址和物理地址的转换
+ 解释孤儿进程，僵死进程，惊群效应
+ 生产-消费者模型，伪代码，用条件变量，注意使用while()替代if()判断是否满足条件
+ C++20里的协程，所以又问了我协程相关的东西，包括内核线程和用户态线程之类的。
+ 为什么要区分内核和用户态
+ linux怎么管理进程内存？
+ 怎么快速定位linux下占用资源很大的程序单元
+  哪些时候会发生上下文切换，上下文切换过程中经历了什么
+ 如果父进程没有调用wait、waitpid，怎么杀死僵尸进程

### 死锁

+ 死锁的四个必要条件



+ 举例子讲解如何解决死锁



---

## 数据库



+ truncate 和delete区别



+ 索引分类和原理----B+树，具体分析



+ 数据库锁有哪些，造成原因



+ 如果在数据库上进行了误操作该怎么处理



+ 数据库sga问题



+ B树和B+树的区别，ACID, 索引种类，explain关键字



+ 介绍一下数据库索引(B+树、哈希索引、LSM树之类)



+ 索引的类别和使用场景
+  Mysql如何实现主从一致性



---

## 调试

### gdb







## 链接与编译





## 网络编程相关

+ 讲讲非阻塞socket
+ 文件读经历了哪些过程

---



### 1.socket

-  **TCP进行socket编程的步骤**
  - 服务端和客户端初始化 socket ，得到文件描述符;
  - 服务端调用 bind ，将绑定在 IP 地址和端口;
  - 服务端调用 listen ，进行监听;
  - 服务端调用 accept ，等待客户端连接；
  - 客户端调用 connect ，向服务器端的地址和端口发起连接请求;
  - 服务端 accept 返回用于传输的 socket 的文件描述符;
  - 客户端调用 write 写入数据;服务端调用 read 读取数据;
  - 客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ， 待处理完 数据后，
  - 服务端调用 close ，表示连接关闭。

-  **服务器端会维护哪两个队列？** 
  - 未完成连接队列(SYN 队列):接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态; 
  - 已完成连接队列(Accpet 队列):已完成 TCP 三次握手过程，处于 ESTABLISHED 状态;

-  **服务器端进行TCP连接(socket连接)时，内核的工作流程**
  - 当客户端发送的SYN请求报文到达后，插入到SYN 队列，随后给对方发送ACK确认报文
  - 当接收到客户端的ACK确认报文后，应用程序从Accpet 队列中取出已完成连接的socket

-  **socket的各个步骤对应 TCP 握手中的哪些阶段？**

  - 客户端初始化 socket ，调用 connect 后，进入SYS-SENT状态，是第一次握手阶段
  - 服务器端初始化 socket ，调用 bind 绑定在 IP 地址和端口，调用 listen 进行监听后，进入Listen状态
  - 服务器端在接收到客户端的 SYN 请求报文后， 调用 accept ，等待客户端连接，并回复ACK确认报文，进入 SYN-RCVD状态
  - 客户端接收到ACK确认报文后，connect函数返回文件操作符，回复ACK确认报文，进入established状态
  - 服务器端收到对方的ACK确认报文后，accpet API 函数返回 文件操作符，进入established状态

-  **为什么一个socket可以accept多次？**

  - 输入参数 fd 是从 socket， bind， listen 中沿用下来的 socket 句柄值，是在指定的端口处监昕所有的连接请求。
  - 调用 accept() 是从 socket fd 的请求队列抽取第一个连接信息，创建新的同类型 socket 句柄 fd 来进行后续操作。
  - 两个fd 是不同的，所以能 accept 多次

-  **客户端调用close后，连接是断开的流程是什么?**

  - 就是四次挥手流程

-  **IO有哪两种操作？**

  - 同步IO：必须等待 IO 操作完成后，控制权才返回给用户进程 。 
  - 异步IO：无须等待 IO 操作完成，就将控制权返回给用户进程 。 

-   **网络IO发生时，设计哪些对象与操作？**

  - 会涉及两个系统对象：调用这个 IO 的 进程，系统内核。
  - 当一个 read操作发生时，会经历两个阶段:
    - 等待数据准备; 
    - 将数据从内核拷贝到进程中。

-  **简单介绍一下4中IO模型。**

  - 阻塞IO：阻塞是指 IO 操作需要彻底完成后才返回到用户空间

    > 阻塞 IO 模型的特点就是：在 IO 执行的两个阶段(等待数据和拷贝数据)都被阻塞了 。

  - 非阻塞IO：非阻塞是指 IO 操作被调用后立即返回给用户一个状态值， 不需要等到 IO 操作彻底完成。

    > `fcntl( fd, F_SETFL, O_NONBLOCK );` 来设置socket成为非阻塞IO

  - 多路IO复用（事件驱动IO）：多路 IO复用 可以监视多个描述符， 一旦某个描述符就绪( 读就绪或写就绪)，能够通知程序进行相应的读写操作。 

    > 调用API后整个进程会被阻塞，而且存在两个系统调用(select与revcfrom)，如果连接数不多，不能体现优势。

  - 异步IO：

    - 用户角度：用户进程发起 read操作之后，立刻就可以开始去做其他的事;
    - 内核角度：当它收到一个异步的 read请求操作之后，首先会立刻返回，所以不会对用户进程产生任何阻塞。 然后，内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切完成后，内核会给用户进程发送一个信号，返回 read操作已完成的信息 。

  > + 阻塞 IO、非阻塞 IO 及多路 IO 复用都属于同步 IO。
  > + 非阻塞 IO在执行 recvfrom 候，若内核的数据没有准备好，不会阻塞进程 。 但当内核中数据准备好时， recvfrom 会将数据从内核拷贝到用户内存中，这时进程仍被阻塞。 
  > + 异步 IO 不同， 当进程发起 IO 操作之后，就直接返回，直到内核发送一个信号，告诉进程 IO 已完成，整个过程中进程完全没有被阻塞。

---

### 3.IO复用

-  **介绍一下 select 系统调用设计的函数**

  ```c++
  #include <sys/select.h>
  void FD_ZERO(fd_set *set); 						//把文件描述符集合里所有位清0
  void FD_CLR(int fd, fd_set *set); 		//把文件描述符集合里fd清0
  int  FD_ISSET(int fd, fd_set *set); 	//测试文件描述符集合里fd是否置1
  void FD_SET(int fd, fd_set *set); 		//把文件描述符集合里fd位置1
  
  struct timeval {
    	long tv_sec; /* seconds */  
    	long tv_usec; /* microseconds */
  };
  
  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
             struct timeval *timeout);
  ```

  **参数：**

  + nfds： 指定被监听的文件描述符的总数。通常设置为被监听的所有fd中的最大值加1，因为fd从0开始计数的。

  + readfds：  监控有读数据到达文件描述符集合，传入传出参数

  + writefds： 监控写数据到达文件描述符集合，传入传出参数

  + exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数

  + timeout： 定时阻塞监控时间，3种情况

    1. NULL，永远等下去

    2. 设置timeval，等待固定时间

    3. 设置timeval里时间均为0，检查描述字后立即返回，轮询

  **返回值：**

  + 成功： **所监听的所有 监听集合中，满足条件的总数**
  + 失败： 返回 -1 并设置errno


---

+  **简单介绍一下select调用过程。**

  1. 在进行 `socket, bind, listen` 后，得到连接请求描述符 `listenfd`。设置数组`client[FD_SETSIZE]`存放文件描述符，全部初始化为 -1。

  2. 设置 存放文件描述符集合 `fd_set rset`，使用 `FD_ZERO(rset)` 进行清零，使用 `FD_SET(listenfd)` 将 `listenfd` 加入集合

  3. 设置 `maxfd = listenfd + 1` ，进行 while 循环，将 `rset` 赋给临时的` readset`，调用 `select` 函数

     > `select (maxfd, &readset,NULL, NULL, NULL)`

  4. 等待 `select` 有返回值时，得到就绪的文件操作符数目 `nready`，先进行判断是否合理，然后利用 `FD_ISSET(listenfd, &rset)`  判断是否有新的连接
  5. 如果有，则调用 `accept` ，返回连接后的文件描述符 `connfd` 。使用 `FD_SET(connfd, &readset); ` 将 `connfd` 放入 `readset` 集合中。
  6. 遍历 `client` 数组，将 `connfd` 放入合适位置，`nready--` 。最后更新 `maxfd`
  7. 随后遍历 client 数组，找出其中的 文件描述符， 使用 `FD_ISSET(sockfd, &rset)` 操作，判断是否存在读事件，如果是，则继续进行任务操作，如 read。  `nready--` 。
  8. 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。 

---

+  **介绍一下 poll 系统调用函数**

  ```c
  #include <poll.h>
  
  struct pollfd {
      int fd; /* 文件描述符 */
  		short events; /* 监控的事件：主要是 POLLIN,POLLOUT,POLLERR */
  		short revents; /* 监控事件中满足条件返回的事件，由内核填充 */
  };
  
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  ```

  **参数：**

  + fds： pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读，可写和异常等事件。
  + nfds： 指定被监听时间集合fds的大小。
  + timeout： 毫秒级等待
    + -1：阻塞等待，#define INFTIM -1         Linux中没有定义此宏
    + = 0：立即返回，不阻塞进程
    + \> 0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值

  **返回值：**

  + 成功： 所监听的所有 监听集合中，满足条件的总数
  + 失败： 返回 -1 并设置errno

---

+  **简单介绍一下poll调用过程。**

  + 定义 pollfd 结构体数组 `struct pollfd client[1024]`，将第一个`client[0]`设置fd与events设置为listenfd与POLLIN，其余fd为-1 ，设置maxi = 1。

  + 进行循环，调用 poll 函数， 返回就绪文件描述符个数，查看`client[0]`是否为 POLLIN事件(`client[0].revents & POLLIN`) 

    > `nready = poll(client, maxi, -1);`

  + 如果是，调用accept得到新的连接文件描述符connfd，将其存放到client数组中合适的位置。更新maxi,nready--。

  + 遍历前面`1-maxi`个client数组，找出就绪的文件描述符，查看是否为POLLIN事件，如果事，则进行下面的任务处理，nready--。

  + 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。

---

+ **介绍一下 epoll 系统调用函数**

  + epoll_create 函数：创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数

    ```c++
    #include <sys/epoll.h>
    
    int epoll_create(int size);
    ```

    + 参数：
      + size：监听数目(告诉Linux内核创建多大的epoll模型)，创建多大结点的红黑树，只是建议值，
    + 返回值：
      + 成功返回 文件描述符，指向红黑树的根
      + 失败返回 -1

  + epoll_ctl 函数：控制某个epoll监控的文件描述符上的事件：注册、修改、删除。

    ```c++
     #include <sys/epoll.h>
    
    struct epoll_event {
    			__uint32_t events; /* Epoll events */
    			epoll_data_t data; /* User data variable */
    };
    
    typedef union epoll_data {
        void *ptr;
        int fd;					//与epoll_ctl函数中的fd对应
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;
    
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    /*
    	epoll_event中的 events:
    	EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
    	EPOLLOUT：	表示对应的文件描述符可以写
    	EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
    	EPOLLERR：	表示对应的文件描述符发生错误
    	EPOLLHUP：	表示对应的文件描述符被挂断；
    	EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
    	EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
    */
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根
      + op ： 在红黑树树上进心增删改：
        + EPOLL_CTL_ADD (注册新的fd到epfd)
        + EPOLL_CTL_MOD (修改已经注册的fd的监听事件)
        + EPOLL_CTL_DEL (从epfd删除一个fd)
      + fd ： 具体需要操作的文件描述符
      + event： 告诉内核需要监听的事件(往往只需要 events 与 data.fd)
    + 返回值：
      + 成功返回 0
      + 失败返回 -1

  + epoll_wait函数： 等待所监控文件描述符上有事件的产生，类似于 select() 调用。

    ```c++
    #include <sys/epoll.h>
    
    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根

      + events ： 是一个传出参数数组

        > epoll_ctl中是传入变量的地址，这个变量初始化好就行
        >
        > epoll_wait中是传入数组，传出满足事件的文件描述符，每个元素都是epoll_event结构体

      + maxevents ： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，

      + timeout ：是超时时间

        +  -1： 阻塞
        +  0： 立即返回，非阻塞
        +  \>0： 指定毫秒

    + 返回值：
      + 成功返回有多少文件描述符就绪
      + 时间到时返回0，
      + 出错返回-1

---

+  **简单介绍一下 epoll 的调用过程**

  1. 通过 `epoll_create` 函数创建 epoll 模型，返回红黑树的根结点作为文件描述符 efd。

  2. 创建epoll_event事件与数组(`struct epoll_event tep, ep[OPEN_MAX]; `)，将tep的event设置为EPOLLIN，data.fd 设置为 listenfd。利用 epoll_ctl 函数将 listen 与 tep 添加到 efd 的红黑树中

     >  `res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep); `

  3. 循环，将 数组 ep 代入epoll_wait函数等待文件描述符就绪，当就绪后，返回就绪的文件描述符数目

     > ` nready = epoll_wait(efd, ep, OPEN_MAX, -1); ` 

  4. 循环 ep 数组中前 nready 个元素，查看是否是EPOLLIN事件(`ep[i].events & EPOLLIN`) 

  5. 如果是，则查看是否为listenfd 就绪(`ep[i].data.fd == listenfd`)，如果是，则调用accpet函数，返回新的连接文件描述符 connfd，重新赋值给 tep ，利用 epoll_ctl 函数将tep 加入红黑树中

  6. 如果不是listenfd 就绪，则取出，赋值给sockef，利用它来完成其他任务操作。

---

+ **介绍一下 epoll 的两种触发模式**

  + **Level Triggered (LT 水平触发)** ：epoll的默认触发方式，既支持阻塞模式，也支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。一次性读写完未全部完成，那么下次调用 epoll_wait()时，还会通知在上次没读写完的文件描述符上继续读写

  + **Edge Triggered (ET 边缘触发)** ： 只支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。一次性全部读写完未完成，那么下次调用epoll_wait()时，不会通知，即只会通知一次，直到该文件描述符上出现第二次可读写事件。

    > 最好是利用边缘触发，使用非阻塞fd，套上while循环将数据一次性读写完成，这样效率更高。

---

+  **在ET模式下当多个连接同时到达时该怎么处理？**

  + 理论上如果多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。

  + 解决办法是用while循环包住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。

---

+  **nigix的实现中多个连接同时到达如何处理？**
  + nigix 中 ，accept函数调用使用水平触发的fd，就是出于对丢失连接的考虑，所以不存在丢失连接的问题。
  + 但是若系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，会大大降低处理程序检索自己关心的就绪文件描述符的效率。

---

+ **使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？**
  + 平时不要把该描述符放进event_poll结构体中，当需要写该fd的时候，调用epoll_ctl把fd加入eventpoll里监听，可写的时候就往里写，写完再次调用epoll_ctl把fd移出event_poll，这种方法在发送很少数据的时候仍要执行两次epoll_ctl操作，有一定的操作代价
  + 改进一下就是：平时不要把该描述符放进event_poll结构体中，需要写的时候调用write或者send写数据，如果返回值是EAGAIN（写缓冲区满了），那么这时候才执行第一种方法的步骤。

---

+ **比较IO复用 select，poll，epoll 的区别**

  + select、 poll和 epoll都是多路 IO 复用机制。 可以监视多个描述符， 一旦某个描述符就绪，会通知程序进行相应的读写操作。 但它们本质上都是同步 IO，因为它们都需要在读写事件就绪后自己负责进行读写，是阻塞的。

  + select的优缺点：

    + select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。
    + select()对于超时值提供了更好的精度，而 poll()是精度较差。
    + select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024
    + select采用的是轮询模型，如果链接客户端过多，会大大降低服务器响应效率

  + poll的优缺点：

    + 可以修改文件描述符的上限数目，优于select
    + 将监听集合 和 返回集合 实现了分离，不像select那么麻烦，搜索范围更小
    + poll在应付大数目的文件描述符时速度更快，对于 select 来说内核需要检查大量描述符对应的set中的每一个比特位，比较费时。
    + 但还是需要将数组全部变量，找出已连接的文件描述符，而不是直接返回满足的文件描述符数组。

  + epoll 的优点

    + 支持ET触发模式，其余两者只支持LT。

    + 不是使用轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；selet 与 poll 调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。

    + 使用 mmap加速内核与用户空间的消息传递

      > 3者都需要内核把fd消息通知给用户空间，如何避免不必要的内存拷贝就显得尤为重要 。 
      >
      > epoll 通过内核 与用户空间 mmap 处于同一块内存实现的 。
      >
      > poll将传入的 pollfd数组拷贝到内核空间，因为拷贝操作和数组长度相关，时间上来看，这是一个 O(n)操作

---

+ Libevent如何处理IO事件，信号事件，和定时事件

  

## WebServer项目相关

+  **介绍一下你的WebServer项目**
  + 这是一个服务器项目
+  **线程池的优点是什么？**
  + 线程池旨在降低创建和销毁线程的频率，使其维持合理数量的线程，并让空闲的线程重新承担新的任务 。
  + 连接池是指维持连接的缓存池，尽量重用已有的连接，降低创建和关闭连接的频率。
  + 这两种技术能降低系统开销，但当请求数目远远大于池中元素的数目时，没有显著的效果。特别是在阻塞IO下。

+ 项目里实现了哪些HTTP请求呢，处理的时候如何分辨这些请求呢？
+ 设想这样一种场景，我的web服务器里面有一张表格，现在浏览器需要请求这个表格中 id=张三 的内容，同时返回到浏览器也需要以表格的形式展现。

---

## 综合面试

+ 智力题 楼层丢鸡蛋
+ 8个赛道，64匹马，要选前4，需要多少轮。
+ 一个检测试剂10分钟检测一位病人，工厂有1000人，最少多少支试剂能10分钟内检测出来哪一位患病？讲出原理（小猪喝水问题的变种
+ 1-100，报号，每次剔除奇数位置的人，问这样剔除以后最后剩下的是几号？64
+ 自我介绍，将自己的经历和项目做一些介绍； 
+ 自己所做邻域的国内外现状、学术界和工业界的状况（因为我研究生期间做的内容比较小众）； 
+ 应聘季自己应聘的优势和劣势； 
+ 对华为的文化怎么理解； 
+ 自己最喜欢的学习方式； 
+ 将来的职业规划；