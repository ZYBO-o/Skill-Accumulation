## C++



### 类

1. 初始化和赋值的区别
2. 拷贝构造函数与赋值运算符重载的区别
3. 哪些情况必须用到成员列表的初始化
4. ==什么是内存对齐原则==
   +  变量按照定义顺序放到内存中时并不是紧密排列的。它都会认为内存是以它自己的大小来划分的，放置的位置一定会在自己宽度的整数倍上开始
5. ==什么是补齐原则==
   + 在经过对齐原则分析后，检查计算存储单元是否为所有元素中所占内存最大的元素的长度的整数倍
     + 是，则结束
     + 不是，补齐为最大元素长度的整数倍
6. ==内存对齐原则与补齐原则的作用==
   + 移植原因：不是所有的硬件平台都能访问任意地址上的任意数据的；这样补齐对移植后操作更友好。
   + 性能原因：程序员看来，内存是由字节组成。而CPU在读取内存时是一块块进行读取的，块的大小可以是2，4，8，16字节。经过内存对齐/补齐后，CPU的内存访问速度大大提升。
7. ==C++类的对象存储空间由哪些因素决定？==
8. C++中struct和class的区别
9. C++和C的struct区别
10. public，protected和private访问和继承权限/public/protected/private的区别？
11. ==volatile、mutable和explicit关键字的用法==
    + 告诉编译器不要将定义的变量优化掉。
    + 让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值
12. C++中类的数据成员和成员函数内存分布
13. ==11.类对象的大小受哪些因素影响==
14. 

### 面向对象程序设计

1. 继承中类的作用域
2. 类对其继承而来的成员的访问权限受什么影响？
3. 派生类的成员能否访问直接基类的成员与什么有关？（只与基类的访问说明符有关）
4. ==C++有哪几种的构造函数==
5. 什么情况下会调用拷贝构造函数
6. 为什么拷贝构造函数必须是引用传递？
7. 派生类拷贝控制成员时的注意事项（拷贝/移动/赋值）
8. 能否在构造函数中抛出异常？（能避免就避免，考虑内存泄露）
9. 能否在析构函数中抛出异常？（资源泄露，student[10]）
10. 类什么时候会析构
11. =delete的使用
12. ==构造函数可以继承吗？==
13. 构造函数的执行步骤是什么？
14. 什么情况下会自动生成默认构造函数
15. 什么时候需要合成拷贝构造函数?
16. 构造函数、析构函数、虚函数可否声明为内联函数（静态绑定时可能）
17. 介绍一下C++中的静态类型与动态类型
18. 什么是编译时绑定和运行时绑定？（this->vptr->vtable[i]->vfunc）
19. 哪些情况下，可以把类的引用/指针绑定到一个对象
20. 类类型的转换与继承，即基类与继承类之间的转换
21. ==为什么需要多态==
22. **<font color = red>介绍一下虚函数的作用和实现原理</font>**
23. ==虚函数与纯虚函数的区别==
24. 介绍一下抽象基类
25. 虚函数有什么代价？
26. 哪些函数不能是虚函数？
27. ==你了解虚函数表和虚表指针吗？== 
28. ==基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间==
29. 使用虚函数有什么便利之处吗？
30. final与 override关键字
31. **<font color = red>为什么析构函数一般写成虚函数</font>**
32. C++中的重载、重写（覆盖）和隐藏的区别
33. C++ 中的多态是如何实现的？
34. **<font color = red>C++中如何利用虚函数表和虚函数指针来实现多态的？</font>**
    + 编译器自动为每个含有虚函数的类生成一份一维数组的虚表，保存虚函数的入口地址，虚表可以继承
    + 如果派生类类没有重写虚函数，派生类虚表中存在指向基类的虚函数实现的虚函数地址
    + 如果派生类重写了相应的虚函数，派生类虚表中的地址就会改变，指向自身的虚函数实现
    + 如果派生类有自己的虚函数，派生类的虚表中就会添加该项。
    + 编译器会在每个对象的前四个字节中保存一个vptr，指向对象所属类的虚表
    + 在构造时，根据对象的类型去初始化vptr，让vptr指向正确的虚表，在调用虚函数时，能找到正确的函数
35. ==构造函数能否声名称虚函数==
    + 虚函数的运行依赖于虚函数指针，而虚函数指针在构造函数中进程初始化，让它指向正确的虚函数表，而在对象构造期间，虚函数指针还未构造完成。
36. 静态函数能定义为虚函数吗？（无this指针，无法调用）





























