## 一. **刷题**

### 面试问过的

+ 给定一个数组num和两个数字L和R，数组长度为n，问你这个数组里面有多少个连续的子数组，满足这个子数组中的最大值大于等于L，小于等于R。
+ 给一个字符串，输出最长连续子串。
+ n的所有最小因数集合，如8，其最小质数集合为{1,2,2,2}
+ 手撕 unique_pointer
+ [个人博客 - 设计parser](https://xyfu.me/posts/de9ec62b/)
+ 布隆过滤器
+ hash表解决冲突的方法
+ 红黑树性质
+ redis中的数据结构
+ 跳表插入删除过程
+ 判断大小端，int的大端转小端
+ 去掉字符串开头和末尾的空格
+ 大数相加
+ 最长公共子序列LCS
+ 最小编辑距离
+ 二叉树中两个节点的最近公共父节点
+ 数据流的中位数
+ [算法题](https://www.nowcoder.com/jump/super-jump/word?word=算法题)是两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组，找中位数。我回答了lc上的O(log M +N )的最优解方法
+ 40E个数，找出唯一不存在的数？进行(内存)优化？大数据问题都是用[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)进行分组，每一组做一次遍历，就可以大大减少内存占用
+ 1~N，其中有两个数重复，找出重复的数？
+ 写个单例模式的例子
+ 设计题，快速找出所有微信关系里的单向好友
+ 一个字符串ajxnhdbdosjbsorange,模式“o*ge”,找到匹配的最小字符串下标范围。
+ hashfunc一般怎么实现(除法散列，乘法散列 等等)
+ hashmap发生冲突怎么解决([链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)法、开放寻址法等等)
+ 1亿个数怎么找中位数(哈希分组，然后快排寻找)
+ 一个字符串，比如abc123/f/ecd,连续的数字或者连续的字母，或者反斜杠后和后面一个字符，视为一个整体，反转之。比如这时输出应该是cd/e/f123abc.(一开始用了栈来做，非常简单。然后面试官问有没有其他方法，我就说一个先分段反转再整体反转的原地做法。
+ 开放寻址法要如何查找一个元素
+ 一个无序数组,如何寻找第n大的数(BFPTR[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法))
+ 单向[链表]()中如何高效删除一个结点（只给定头指针和指向当前结点的指针）  
+ 给定n个正整数，如何找出最小的K个正整数 
+ 给定一组整数1000以内，如何高效去除重复的数
+ 字符串中查找是否有子串，写完以后要求给出测试用例



##  二 .C++

+ 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？
+ 虚函数的作用及实现原理
+ 局部变量、全局变量、常量还有malloc开辟的内存变量分别放在哪个区
+ 全局变量的初始化位置
+ 游戏中，有些资源文件需要频繁使用，如何进行加速  
+ 游戏中，如果有一个AOE的BUFF（类似皇子的旗子E技能），如何实时快速计算这些技能的影响单位 

---

### C相关问题

##### 1. **C程序如何启动和终止的**

+ 内核调用一个exec函数，调用exec的进程将命令行参数传递给启动例程，然后启动例程调用main函数。
+ 进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用\_exit或 \_Exit。进程也可非自愿地由一个信号使其终止。

---

##### 2. **atexit函数**

+ atexit函数类似于C++类中的析构函数，在main函数结束之后被exit调用，调用顺序与登记顺序相反。同一函数如若登记多次也会被调用多次。
+ `atexit`的参数是一个函数地址，无需传递参数,也不期望返回值。

---

##### 3. **C程序的存储地址空间布局**

+ 从低地址往高地址分别为： 正文段—> 初始化数据段—> 未初始化数据段—> 堆——>栈。
+ 它们的主要作用：
  + 正文段：这部分是共享的，也是只读的，是CPU执行的机器指令部分。
  + 初始化数据段：包含程序中需明确地赋初值的变量
  + 未初始化数据段：也称为bss段( block started by symbol)，在程序执行之前，内核将该段中的数据初始化为0或空指针。
  + 堆：动态分配存储的区域
  + 栈：自动变量以及函数调用所需要保存信息的区域

---

##### 4. **讲一下存储空间分配函数——malloc, realloc, calloc各自的用法**

+ `void *malloc(size_t size);`  分配指定字节数的存储区，初始值不确定
+ `void *calloc(size_t nobj, size_t size);` 分配指定 数目，长度 的存储空间， 初始化为0
+ `void *realloc(void *ptr, size_t newsize);` 增加或减少以前分配区的长度，新增区初始值不确定

##### 5. **C++ 中的 string 与 C 中的 `char *` 有什么区别？**

+ string继承自 basic_string ，是对 `char` 进行了封装，包含 char 数组，容量，长度等属性
+ string可以动态扩展，每次扩展是原空间的两倍，将原内容拷贝进去。

### C++基本介绍

---

+  struct和union的区别
+  知道虚函数表指针在内存中是怎么分布的吗？(我直接按照Lippman那本书回答)。
+  虚函数表指针放在头部和尾部的好处分别是什么？(自己挖的坑。。)

---

##### 1. 聊一聊C++面向对象的三大特性

> C++ 的三大特性就是继承，封装和多态。

+ 继承：让某种类型对象获得另一个类型对象的属性和方法。有三种继承方式：
  + 实现继承：指使用基类的属性和方法而无需额外编码的能力
  + 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力
  + 可视继承：(C++里好像不怎么用)
+ 封装：变量和方法捆绑成类，可以对它们进行信息隐藏，只让可信的对象和类操作。
+ 多态：同一事物表现出不同事物的能力。实现多态的两种方式：
  + 覆盖： 是指子类重新定义父类的虚函数的做法。
  + 重载：是指允许存在多个同名函数，而函数的参数表不同

---

### 变量与基本类型

---

##### 1. **变量与定义的区别**

+ 声明仅仅将变量声明的位置与类型提供给编译器，并不分配内存。定义会在定义的地方直接分配存储空间。
+ 相同变量可在多处声明，但只能一处定义。

---

##### 2. **什么情况下必须用到初始化成员列表**

+ 初始化const成员
+ 初始化reference成员
+ 调用基类的构造函数，该函数有参数
+ 调用数据成员对象的构造函数，该函数有参数

---

##### 3. **常量指针与指针常量的区别**

+ 常量指针指常量的指针，注重常量，不能修改指定的值 ：`int const *p` 或 `const int *p`
+ 指针常量指不能修改指针的指向，指针是一个常量： `int *const p` 。

---

##### 4.**介绍野指针与空悬指针，如何避免？**

+ 野指针：没有初始化的指针
+ 空悬指针： 指针最初指向的内存已经被释放了的一种指针。
+ 解决方法：使用完置空，或者使用智能指针。

---

##### 5.  区别以下指针类型？

- `int* p[10]`
  - 表示指针数组， **强调数组概念** ，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- `int (*p)[10]`
  - 表示数组指针， **强调是指针** ，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- `int *p(int)`
  - 是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- `int (*p)(int)`
  - 是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

---

##### 6.指针和引用的区别

- 指针是一个存储地址的变量，占内存；引用原变量的别名，不占内存
- 指针可以有 **多级** ，引用只有一级
- 指针可以为空，引用不能为`NULL`且在定义时 **必须初始化**
- 指针在初始化后 **可以改变指向** ，而引用在初始化之后 **不可再改变**

- 使用`sizeof` ，
  - 指针得到的是本指针的大小
  - 引用得到的是指向变量的大小

+ **当把指针作为参数进行传递时，也是<font color = red>将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</font>**

---

##### 7.C++中static的作用

:small_blue_diamond:  **static成员变量** 

+ 静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。即只要分配一次内存(定义时就分配)，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新；
+ 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。
+ 同全局变量相比，使用静态数据成员有两个优势：
  + 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；
  + 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；

:small_blue_diamond:  **static成员函数**

+ 静态数据成员为类的全部服务而不是为某一个类的具体对象服务。
+ 与普通函数相比，静态成员函数由于不与任何的对象相联系，因此它不具有this指针。它无法访问非静态数据成员与非静态成员函数，它只能调用其余的静态成员函数。非静态成员函数可以任意地访问静态成员函数和静态数据成员。

+ 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；
+ 调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指针调用静态成员函数，也可以直接使用如下格式：`＜类名＞::＜静态成员函数名＞（＜参数表＞）`调用类的静态成员函数。

##### 8.C++中const的作用

:small_blue_diamond:  **const成员变量**

- 必须有构造函数；不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化
- 不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化

:small_blue_diamond: **const成员函数**

+ const对象不可以调用非const成员函数；
+ 非const对象都可以调用；
+ 不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值

---

##### 9.C++的顶层const和底层const

>  **指针本身是不是一个常量** 以及 **指针所指的是不是一个常量** 是两个独立的问题。

- **顶层**const：指的是 **指针本身是一个常量**
- **底层**const：指的是 **指针所指的对象是一个常量**

```c++
int i= 0；
int* const p1 = &i; 				//不能改变p1的值，顶层const
const int ci = 42;					//不能改变ci的值，顶层const
const int *p2 = &ci; 				//允许改变P2的值，底层const
const int *const p3 = p2;		//靠右的const是顶层const，靠左的const是底层const
const int &r = ci;					//用于声明引用的const都是底层const
```

- `const int *a`，a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。
- `int *const a`，依旧是指针类型，表示a为指向整型数据的常指针。(看成`const(a)`，对指针const)

---

##### 10.constexpr与常量表达式

+ **常量表达式** 是指 **值不会改变** 并且在 **编译过程就能得到计算结果** 的表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。

```c++
const int max_files = 20;			// 是常量表达式
const int limit = max_files + 1;	// 是常量表达式
int staff_size = 2;					// 不是常量表达式
//sz本身是一个常量，但是具体值直到运行时才能获取，所以不是常量表达式
const int sz = get_size();			// 不是常量表达式
```

+ C++允许将 **变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式** 。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化

---

##### 11.auto、decltype和decltype(auto)的用法

+ C++11新标准引入了auto类型让编译器去分析表达式所属的类型。所以说 auto 定义的变量必须有初始值。举个例子：

+ decltype作用是选择并返回操作数的数据类型。编译器只分析表达式并得到它的类型，不进行实际的计算表达式的值

```c++
 int func() {return 0};

 //普通类型
 decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()
 int a = 0;
 decltype(a) b = 4; // a的类型是int, 所以b的类型也是int
 //引用与指针类型
 //1. 如果表达式是引用类型, 那么decltype的类型也是引用
 const int i = 3, &j = i;
 decltype(j) k = 5; // k的类型是 const int&
 //2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
 int i = 3, &r = i;
 decltype(r + 0) t = 5; // 此时是int类型
 //3. 对指针的解引用操作返回的是引用类型
 int i = 3, j = 6, *p = &i;
 decltype(*p) c = j; // c是int&类型, c和j绑定在一起
 //4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
 int i = 3;
 decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起
```

##### 12.define宏定义和const的区别

- define是在编译的**预处理**阶段起作用，只做替换，不做类型检查和计算，也不求解，容易产生错误；宏定义的数据没有分配内存空间，只是插入替换掉
- const是在编译、运行的时候起作用；const常量有数据类型，编译器可以对其进行类型安全检查；const定义的变量只是值不能改变，但要分配内存空间。

---

##### 13.C++的四种强制转换类型

**reinterpret_cast** ：`reinpreter_cast (expression)`

+ 

**const_cast** ：`const_cast<type-id>( expression )` 

+ 修改类型的const或volatile属性。可以使一个不是const类型的数据转换成const类型的
  + 常量指针被转化成非常量的指针
  + 常量引用被转换成非常量的引用
  + const_cast一般用于修改指针。如const char *p形式。

**static_cast** ：`static_cast < type-id > ( expression )`

+ 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。
  + void指针->其他类型指针
  + 改变通常的标准转换
  + 避免出现可能多种转换的歧义

**dynamic_cast**：`dynamic_cast < type-id > ( expression )`

+ 该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用





---

### 字符串，向量和数组

##### 1.数组名和指针（这里为指向数组首元素的指针）区别？

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，不能自增、自减；可以理解为常指针。
- 数组名当做形参传递给调用函数后，会失去原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

---

##### 2.拷贝初始化和直接初始化

+ 直接初始化直接调用与实参匹配的构造函数
+ 拷贝初始化调用拷贝构造函数。拷贝初始化先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将临时对象拷贝到正在创建的对象。

---

##### 3.strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得，不能用来得到动态分配（运行时分配）存储空间的大小。sizeof参数可以是任何数据的类型或者数据
- strlen是字符处理的库函数。参数只能是字符指针且结尾是'\0'的字符串。

---

### 类

##### 1.初始化和赋值的区别

- 对于简单类型来说，初始化和赋值没什么区别。类中成员初始化顺序与它们在类定义中的出现顺序一致

- 对于类和复杂数据类型来说就不一样了，如果是定义时，初始化会调用构造函数，赋值初始化会调用拷贝构造函数，如果是定义好的变量进行赋值，会调用赋值操作符重载函数。


##### 2.哪些情况必须用到成员列表的初始化

1. 当初始化一个引用成员时;
2. 当初始化一个常量成员时;
3. 当调用一个基类的构造函数，而它拥有一组参数时; 
4. 当调用一个成员类的构造函数，而它拥有一组参数时;

> 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用 户代码之前;
>

---

##### 2. C中结构体内存对齐问题？

```c++
struct number_2{
    char a;
    int b;
    double c;
}st2;
```

> st2所占内存并非1+4+8=13个，而是16个>13个。

对齐原则： **结构体变量中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。**

```c++
struct number_4{
    char a;
    int b;
    char c;
}st4;
```

> sizeof(st4)=12,而不是4+4+1=9。

补齐原则： **在经过对齐原则分析后，检查计算出的存储单元是否为所有元素中所占内存最大的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。**


---

##### 3.C++类的对象存储空间？

对于类实例化一个对象，我们要计算这个对象所占的存储空间大小，其存储空间大小计算为（权威解答）：

+ **非静态成员变量总和；**
+ 加上 **编译器为CPU计算做出的数据对齐处理；**
+ 加上 **支持虚函数所产生的负担的总和。**

以上三种的加和即为当前对象的占有的存储空间的大小。

```c++
class Test {
};
int main() {
    Test test0;
    cout << sizeof(test0) << endl;
}
```

> 输出为：1
>
> 空类，没有任何成员变量和成员函数，编译器是支持空类实例化对象的，对象必须要被分配内存空间才有意义，这里编译器默认分配了 1Byte 内存空间(不同的编译器可能不同)

```c++
class Test {
private:
    int i;
    char c;
    double d;
};
int main() {
    Test test1;
    cout << sizeof(test1) << endl;
}
// 输出为：16

class A{};
class Test {
private:
    int i;
    char c;
    double d;
    A a;
};
int main() {
    Test test2;
    cout << sizeof(test2) << endl;
}
//输出为：24

class A {
private:
    double dd;
    int ii;
    int* pp;
};
class Test {
private:
    int i;
    A a;
    double d;
    char* p;
};
int main() {
  	A a;
    Test test3;
    cout << sizeof(test3) << endl;
  	cout << sizeof(a) << endl;
    cout << sizeof(test1.pp) << endl;
}
//输出为：
//48
//24
//8
```

> - 这里的类的内存对齐原则与前面写的结构体的内存对齐原则是一样的(不太了解的可以移步我之前的《C/C++中内存对齐问题的一些理解》查看)
> - 测试三中，32bit 目标平台寻址空间是 4Byte(32bit)，所以指针是 4Byte的；64bit 目标平台寻址空间是 8Byte(64bit)，所以指针是 8Byte
> - 另外，静态成员变量是在编译阶段就在静态区分配好内存的，所以静态成员变量的内存大小不计入类空间

```c++
class A {
public:
    int n;
    char c;
    short s;
};
class Test {
public:
    Test() {
    }
    int func0() {
        return n;
    }
    friend int func1();

    int func2() const {
        return s;
    }
    inline void func3() {
        cout << "inline function" << endl;
    }
    static void func4() {
        cout << "static function" << endl;
    }
    virtual void func5() {
        cout << "virtual function" << endl;
    }
    ~Test() {
    }

private:
    int n;
    char c;
    short s;
};

int func1() {
    Test t;
    return t.c;
}
int main() {
  	A a;
    Test test4;
    cout << sizeof(test4) << endl;
  	cout << sizeof(a) << endl;
    cout << sizeof(test1.n) << endl;
  	cout << sizeof(test1.c) << endl;
  	cout << sizeof(test1.s) << endl;
}
//输出:
//16
//8
//4
//1
//2
```

> - 因 C++中成员函数和非成员函数都是存放在代码区的，故类中一般成员函数、友元函数，内联函数还是静态成员函数都不计入类的内存空间，测试一和测试二对比可证明这一点
> - 测试三中，因出现了虚函数，故类要维护一个指向虚函数表的指针，分别在 x86目标平台和x64目标平台下编译运行的结果可证明这一点，x64下虚函数表占了8字节

---

##### 4.C++有哪几种的构造函数

C++中的构造函数可以分为4类：

- **默认构造函数**
- **初始化构造函数（有参数）**
- **拷贝构造函数**
- **移动构造函数（move和右值引用）**
- **委托构造函数**
- **转换构造函数**

举个例子：

```c++
#include <iostream>
using namespace std;

class Student{
public:
    Student(){//默认构造函数，没有参数
        this->age = 20;
        this->num = 1000;
    };  
    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致
        this->age = s.age;
        this->num = s.num;
    }; 
    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参
        this->age = r;
        this->num = 1002;
    };
  	Student(std::istream &is) : Student() {//委托构造函数，他委托给了默认构造函数。当这些受委托的构造函数执行完后，接着执行istream&构造函数体的内容。
      	read(is, *this);
    }
    ~Student(){}
public:
    int age;
    int num;
};

int main(){
    Student s1;
    Student s2(18,1001);
    int a = 10;
    Student s3(a);
    Student s4(s3);

    printf("s1 age:%d, num:%d\n", s1.age, s1.num);
    printf("s2 age:%d, num:%d\n", s2.age, s2.num);
    printf("s3 age:%d, num:%d\n", s3.age, s3.num);
    printf("s2 age:%d, num:%d\n", s4.age, s4.num);
    return 0;
}
//运行结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002
```

- 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作
- 复制构造函数用于复制本类的对象
- 转换构造函数用于将其他类型的变量，隐式转换为本类对象

---

##### 5.有关友元

- 类通过增加friend关键字在函数开头进行声明来将其作为友元，这样就允许函数访问自己的非公有成员。
- 友元声明只能在类的内部，但是 **声明友元之外必须再专门对函数进行一次声明。**

```c++
class Sales_data{
    friend Sales_data add (const Sales_data&, const Sales_data&);
  	...
public:
    Sales_data() = default;
    ...

private:
    double avg_price () const
        { return unit_sold ? revenue/unit_sold : 0; }
    string bookNo;
    ...
};
Sales_data add (const Sales_data&, const Sales_data&);
```

- 当一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。
- 友元不具有传递性。
- 也可以令成员函数作为友元。
- 当类想把一组重载函数声明成友元时，必须每一个都进行声明。

---

#####  6.using 与 typedef

> 在用来定义类型的成员必须先定义后使用，这一点和普通成员变量有所区别。

**typedef**  ：别名命名方式： `typedef std::string::size_type pos`

**using** ：别名命名方式： `using pos = std::string::size_type`

---

##### 7.类的静态成员

- 类的`静态成员`只与类本身相关，与其任何对象都无关。静态成员不与任何对象绑定，不存在`this指针`。也不能被声明为const成员函数

- 静态成员的定义：

  + `静态成员函数`可在类内或类外定义，在类外定义时不可重复static关键字，`static只出现在声明中`。
  + `静态数据成员`并非在创建类时被定义，因此`静态数据成员不由构造函数初始化`。不能在类内部初始化`静态数据成员`，`静态数据成员必须在类外定义和初始化`，一个静态数据成员只能被定义一次
  + `静态成员函数可在类内和类外定义，静态数据成员只能在类外定义和初始化`
  
- 静态成员的访问方式：

  + 可用类的`作用域运算符`直接访问静态成员，也可用类的对象、引用、指针来访问静态成员
  + 成员函数不用通过作用域运算符就可访问静态成员

- 例子：声明、定义、访问静态成员

  ```c++
  //声明静态成员
  class Account{
  public:
      void calculate() {amount+=amount*interestRate;}
      static double rate() {return interestRate;} //静态成员函数，它可在类内也可在类外定义
      static void rate(double);                   //静态成员函数
  private:
      string owner;
      double amount;
      static double interestRate;                 //静态成员变量
      static double initRate();                   //静态成员函数
  };
  //定义静态成员
  void Account::rate(double newRate){         //定义静态成员函数，它可在类内也可在类外定义
      interestRate=newRate;
  }
  double Account::interestRate=initRate();    //定义静态成员变量，它只能在类外定义和初始化
  //访问静态成员
  double r;
  r=Account::rate();  //通过作用域访问
  Account ac1;
  Account *ac2=&ac1;
  r=ac1.rate();       //通过类引用访问
  r=ac2->rate();      //通过类指针访问
  ```


---

##### 8. C++中struct和class的区别

+ 相同点
  + 两者都拥有成员函数、公有和私有部分
  + 任何可以使用class完成的工作，同样可以使用struct完成

+ 不同点
  + 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
  + class默认是private继承，而struct模式是public继承
  + class可以作为模板类型，struct不行

---

##### 9. C++和C的struct区别

- C语言中：struct是用户自定义数据类型（UDT），是结构体；C++中struct是抽象数据类型（ADT），是类
- C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）

---

##### 10. public，protected和private访问和继承权限/public/protected/private的区别？

+ 访问权限：
  + public的变量和函数在类的内部外部都可以访问。
  + protected的变量和函数只能在类的内部和其派生类中访问。
  + private修饰的元素只能在类内访问。

+ 继承权限
  + public继承：
    + 基类的公有成员和保护成员作为派生类的成员时保持原有的状态，私有成员任然是私有，不能被派生类的子类所访问
  + protected继承：
    + 基类的公有成员和保护成员都成为派生类的保护成员，只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的
  + private继承：
    + 基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承


---

##### 11.volatile、mutable和explicit关键字的用法

+ volatile 关键字是一种类型修饰符，在c/c++中的作用：
  + 告诉编译器不要将定义的变量优化掉。
  + 告诉编译器总是从缓存取被修饰的变量值，而不是寄存器取值。

+  **多线程下的volatile** 
  + 当两个线程都用一个要改变值的变量时，用volatile声明，防止优化编译器把变量从内存装入CPU寄存器。如果变量被装入寄存器，两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。
  + volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

+ 被mutable修饰的变量，将永远处于可变的状态。需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。

+ explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。explicit 关键字作用于单个参数的构造函数。

---

##### 12.C++中类的数据成员和成员函数内存分布

类分为成员变量和成员函数：

+ 类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。(在定义类对象的同时这些成员变量也就被定义了)
+ 成员函数不占用对象的内存。因为函数都是存放在代码区，包括静态成员函数。静态成员函数与一般成员函数的唯一区别就是没有this指针 ，因此不能访问非静态数据成员。


```c++
#include <iostream>
using namespace std;
class Person{
public:
    Person(){
    		this->age = 23;
    }
    void printAge(){
        cout << this->age <<endl;
    }
    ~Person(){}
public:
		int age; 
};
int main() {
    Person p;
    cout << "对象地址:"<< &p <<endl;
    cout << "age地址:"<< &(p.age) <<endl;
    cout << "对象大小:"<< sizeof(p) <<endl; cout << "age大小:"<< sizeof(p.age) <<endl; return 0;
}
//输出结果 
//对象地址:0x7fffec0f15a8 
//age地址:0x7fffec0f15a8 
//对象大小:4
//age大小:4
```

---

##### 13.类对象的大小受哪些因素影响

+ 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小; 
+ 虚函数的话，会在类对象插入vptr指针，加上指针大小;
+ 当该该类是某类的派生类，继承的基类部分的数据成员也会存在在派生类中的空间中

```c++
class A {};
int main(){
		cout<<sizeof(A)<<endl;// 输出 1; A a;
		cout<<sizeof(a)<<endl;// 输出 1; return 0;
}
```

空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。

当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

```c++
class A { 
  	virtual Fun(){} 
};
int main(){
    cout<<sizeof(A)<<endl;// 输出 4(32位机器)/8(64位机器); A a;
    cout<<sizeof(a)<<endl;// 输出 4(32位机器)/8(64位机器); return 0;
}
```

因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节

```c++
class A { static int a; };
int main(){
		cout<<sizeof(A)<<endl;// 输出 1; 
  	A a;
		cout<<sizeof(a)<<endl;// 输出 1; 
  	return 0;
}
```

```C++
class A { int a; };
int main(){
    cout<<sizeof(A)<<endl;// 输出 4; 
  	A a;
    cout<<sizeof(a)<<endl;// 输出 4; 
  	return 0;
}
```

```c++
class A { static int a; int b; };;
int main(){
    cout<<sizeof(A)<<endl;// 输出 4; 
  	A a;
    cout<<sizeof(a)<<endl;// 输出 4;静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节 
  	return 0;
}
```

---

##### 13.有关this指针

+ this指针是类的指针，指向对象的首地址。只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。 


##### 14.this指针是什么时候创建的?

+ this在成员函数的开始执行前构造，在成员的执行结束后清除。

##### 15.this 指针存放在何处? 

+ this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在

##### 16. **this指针是如何传递类中的函数的**

+ 大多数编译器通过ecx(寄数寄存器)寄存器传递this指针。

+ this是通过函数参数的首参来传递的。在调用之前，编译器会把对应的对象地址放到eax中。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的.

##### 17. **每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数?**

+ 不论是成员函数，还是静态函数都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。
+ 但是即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接利用this指针调用该函数。

##### 18. 在成员函数中调用delete this会出现什么问题?对象还可以使用吗?

+ 当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

##### 19. 如果在类的析构函数中调用delete this，会发生什么?

+ 会导致堆栈溢出。delete的本质是 **“为将被释放的内存调用一个或多个析构函数，然后，释放内存”** 。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

##### 20. **this指针调用成员变量时，堆栈会发生什么变化?**

+ 当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。

+ 当建立了类的多个对象时，在调用类的成员函数时并不知道具体是哪个对象在调用，此可以通过查看this指针来查看具。this指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。

---

##### 21. 拷贝构造函数与赋值运算符重载的区别

+  拷贝构造函数是函数，赋值运算符是运算符重载。拷贝构造函数会生成新的类对象，赋值运算符不能。
+  拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要检查是否和源对象相同，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。
+  形参传递是调用拷贝构造函数(调用的被赋值对象的拷贝构造函数)，但并不是所有出现"="的地方 都是使用赋值运算符，如下:

```c++
Student s;
Student s1 = s; // 调用拷贝构造函数 Student s2;
s2 = s; // 赋值运算符操作
```

---

## 三. STL

### STL基本介绍

##### 1.介绍一下STL 提供六大组件

**1、容器（containers）**：各种数据结构，如vector, list, deque, set, map。从实现角度看，容器是一种 class template。

**2、算法（algorithms）**：各种常用的算法，如 sort, search, copy, erase…从实现角度来看，算法是一种 function template。

**3、迭代器（iterators）**：扮演容器与算法之间的胶合剂，是所谓的“泛型指针”。从实现角度来看，迭代器是一种将 operator *, operator ->, operator++, operator– 等指针相关操作予以重载的class template。

**4、仿函数（functors）**：行为类似函数，可以作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或class template。

**5、适配器（adapters）**：一种用来修饰容器或仿函数或迭代器接口的东西。例如 STL 提供的 queue 和 stack，虽然看似容器，其实只能算是一种容器适配器，因为底层由 deque 实现。

**6、配置器（allocator）**：负责空间配置与管理，从实现角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的 class template。

> Array 与 forward_list是 C++ 11新增的 

---

### string

##### 1. string 与 C字符串的转换

+  data() 以字符数组的形式返回字符串内容，但并不添加 `'\0'`;
+  c_str() 返回一个以 `'\0'` 结尾的字符数组;
+  copy() 则把字符串的内容复制或写入既有的 c_string 或字符数组内。

> 需要注意的是， C++字符串并不以喻’结尾。

```c++
int copy(p, n, size_type _Off = 0);//将所调用的对象中第 string _Off 位置的 n 个字符复制到 p 指向的空间
str = "hello world";
const char * cstr1 = str.data();
const char * cstr = str.c_str();
cout << cstr1 << " " << cstr2<< endl;//hello world
str = "OK";
cout << cstr1 << " " << cstr2<< endl;//OK OK 
```

---

##### 2.string 与 int 类型的转换

+ int 转为 string 的方法

  ```c++
  int snprintf(char *str, size_t size, co口st char *format, ...)
    
  char a[20] ;
  int i = snprintf(a, 9, "%d",   12345) ;
  cout << i <<" "<< a << endl;	//5 12345
  ```

  + 它将可变个参数 (...) 按照 format格式化成字符串，然后将其复制到str中

+ string 转为 int 类型

  + 使用 strtol, stroll, strtoul 或 strtoull 等函数

    ```c++
    char *endptr ;
    char nptr []= ” 123abc”;
    int ret =strtol(nptr, &endptr, 10 ); //指定为十进制
    cout<<”ret:”<<ret<<" "<<endptr:”<< endptr<<endl;
    //ret:123 endptr:abc
    ```

---

##### 3.string的操作方法

+ string 的截取操作：
  + `string substr (size_t pos = 0, size_t len = npos) const;`：拷贝 pos 位置开始的 len 长的字符串作为子串，pos默认为0

+ string的插入操作：
  + `s.insert(pos, args)` ：在pos之前插入args指定的字符
    + pos可以是下标，也可以是迭代器
  + `s.append(args)` ：将 args 追加到 s

+ string 的修改操作：
  + `s.assgin(args)`：将args替换string中的字符
  + `s.replace(range, args)`：将args代替 s 中 range 范围的字符串
    + range 可以是一个下标和长度，也可以是一对指向 s 的迭代器
+ string的删除操作：
  + `s.erase(pos,len)`：删除从 pos 开始 的 len 个字符，如果 len 被省略，则删除 pos 后的所有字符 

+ 比较大小：compare函数

---

##### 4. string 的搜索操作：

+ `s.find(args)` ：查找 s 中args第一次出现的位置
+  `s.rfind(args)` ：查找 s 中args最后一次出现的位置
+ `s.find_first_of(args)` ：查找 s 中args中任意一个字符第一次出现的位置
+ `s.find_last_of(args)` ：查找 s 中args中任意一个字符最后一次出现的位置
+ `s.find_first_not_of(args)` ：查找 s 中查找第一个不在args中的位置
+ `s.find_last_not_of(args)` ：查找 s 中查找最后一个不在args中的位置

找到返回下标，不在返回`string::npos`，是一个static成员，初始化为 -1

> args: (c,pos)  从s中位置pos开始查找c

---

### Array

##### 1. 介绍一下Array

+ `std::array` 是封装固定大小数组的容器。底层为静态数组，大小固定，不可扩容，但操作更安全。
+ 结合了 C 风格数组的性能、可访问性与容器的优点，比如可获取大小、支持赋值、随机访问迭代器等。

---

### vector

##### 1.vector元素怎么排序

+ 在类中定义重载<函数
+ 定义比较函数，sort参数中应用比较函数

---

##### 2.vector的操作方式

+ vector的查找：`find(vec.begin(), vec.end(), num)`

  + 使用 find 函数在 vector 中进行查找 

+ vector的删除： （返回删除元素之后元素的迭代器）

  ```c
  iterator erase (iterator position) 
  iterator erase (iterator first , iterator last ) 
  vec.pop_back()
  ```

  + 需要注意的是，删除非最后元素之后迭代器会失效，所以操作之后需要重新更新 迭代器

    ```c
    vector<int>::iterator iter = vec.begin();
    for(; iter != vec.end(); ){
      	if(*iter == 3) {
          	iter = vec.erase(iter);
        } else {
          	++ iter;
        }
    }
    ```

+ vector的增加

  + push_back：在容器最后添加元素
  + emplace_back：在容器最后构建元素
  + insert：在位置前插入

  ```c++
  //在指定位置 loc 前插入值为 val 的元素，返回指向这个元素的迭代器
  iterator insert (iterator loc , const TYPE &val ) ;
  //在指定位置 loc 前插入 num 个值为 val 的元素
  void insert( iterator loc , size_type num, const TYPE &val) ; 
  //在指定位置 loc 前插入区间[ start, end)的所有元素
  void insert( iterator loc , input_iterator start, input_iterator end) ;
  ```

---

##### 3.vector的内存管理

+ v.size()：获得容器中有多少元素
+ v.capacity()：获得容器在它已经分配的内存中可以容纳多少元素 
+ v.resize(Container::size_type n)：强制把容器改为容纳 n个元素 ，不影响capacity
  + n 小于size，容器尾部的元素会被销毁
  + n 大于size，新默认构造的元素会添加到容器尾部。 如果 n 大于capacity，在元素加入之前会进行重新分配 
+ v.reserve(Container::size_type n)：强制容器把它的容量改为不小于n，不影响size
  + 小于等于当前capacity时，reserve什么都不做
  + 大于当前capacity时，reserve扩张容量

- v.shrink_to_fit()：C++11方法，要求vector/string/deque退回多余的空间，但具体实现可忽略此要求。不保证能退回

vector采用的`内存扩张策略`一般是：在每次需要分配新空间时，将当前容量翻倍。但具体实现可使用不同策略

---

##### 4. vector的迭代器类型与数据成员

+ 迭代器类型： `Random Access Iterator` 
+ 数据成员：三个迭代器(指针) `first,last,end`

---

##### 5. vector 上常见操作的复杂度（效率）

- 随机访问——常数 *O(1)*
- 在结尾或起始插入或移除元素——常数 *O(1)*
- 插入或移除元素——线性 *O(n)*

---

### deque

##### 1. 介绍一下 deque

+ `std::deque` （ double-ended queue ，双端队列）是有下标顺序容器，它允许在其首尾两段快速插入及删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。

---

##### 2. 与vector比有什么优势

+ 与 `std::vector` 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。
+ deque 的存储按需自动扩展及收缩。扩张 deque 比扩张vector更优，因为它不涉及到复制既存元素到新内存位置。

---

##### 3. deque的迭代器类型与数据成员：

+ 迭代器类型： `Random Access Iterator`
+ 数据成员：一个迭代器，内部拥有四个指针 `head, tail, cur, node`

---

##### 4. deque 上常见操作的复杂度（效率）

- 随机访问——常数 *O(1)*
- 在结尾或起始插入或移除元素——常数 *O(1)*
- 插入或移除元素——线性 *O(n)*

---

### forward_list

##### 1. 介绍一下 forward_list

+ `std::forward_list` 是支持从容器中的任何位置快速插入和移除元素的容器。不支持快速随机访问。它实现为单链表，且实质上与其在 C 中实现相比无任何开销。
+ 与 `std::list` 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。

+ 在链表内或跨数个链表添加、移除和移动元素，不会非法化当前指代链表中其他元素的迭代器。然而，在从链表移除元素时，指代对应元素的迭代器或引用会被非法化。

---

##### 2. forward_list 操作

```c++
lst.insert_after(p,...);//p为迭代器
emplace_after(p,args);  //在p位置后面构建一个元素
lst.erase_after(p);			//删除 p 后面的元素
lst.erase_after(b,e);		//删除 [b,e) 之间的元素
```

- 对forward_list（单向链表）的元素做插入/删除，需要知道其`前驱`。
- forward_list的插入/删除改变的不是指定元素，而是指定元素之后的一个元素
- forward_list定义了`before_begin`迭代器，它指向首元素之前，称为`首前迭代器` ，不能解引用

---

##### 3. forward_list的迭代器类型与数据成员：

+ 迭代器类型： `Forward Iterator` ，不支持 -- 操作，其余都支持
+ 数据成员：一个指针 `head` ,表示头结点

---

##### 4. forward_list 上常见操作的复杂度（效率）

- 插入或移除元素——常数 *O(1)*
- 查询操作——线性 *O(n)*

---

### list

##### 1. 介绍一下list

+ `std::list` 是支持常数时间从容器任何位置插入和移除元素的容器。不支持快速随机访问。它通常实现为双向链表。与 `std::forward_list` 相比，此容器提供双向迭代但在空间上效率稍低。
+ 在 list 内或在数个 list 间添加、移除和移动元素不会非法化迭代器或引用。迭代器仅在对应元素被删除时非法化。

---

##### 2. list的迭代器类型与数据成员：

+ 迭代器类型： `Bidirectional Iterator` ，支持 -- 操作
+ 数据成员：一个尾指针 `node` ,实现环状链表

---

##### 3. list 上常见操作的复杂度（效率）

- 插入或移除元素——常数 *O(1)*
- 查询操作——线性 *O(n)* 

---

### 关联容器

实现在C++中，set 和 map 分别提供了以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| -------------------- | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| `std::set`           | 红黑树   | 有序     | 否               | 否           | $O(log_n)$ | $O(log_n)$ |
| `std::multiset`      | 红黑树   | 有序     | 是               | 否           | $O(log_n)$ | $O(log_n)$ |
| `std::unordered_set` | 哈希表   | 无序     | 否               | 否           | $O(1)$     | $O(1)$     |

`std::unordered_set`底层实现为哈希表，`std::set` 和`std::multiset` 的底层实现是红黑树， **红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。**

| 映射                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| -------------------- | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| `std::map`           | 红黑树   | Key有序  | key不可重复      | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| `std::multimap`      | 红黑树   | Key有序  | key可重复        | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| `std::unordered_map` | 哈希表   | Key无序  | key不可重复      | key不可修改  | $O(1)$     | $O(1)$     |

`std::unordered_map` 底层实现为哈希表，`std::map` 和`std::multimap` 的底层实现是红黑树。同理，`std::map` 和`std::multimap` 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

##### 1.红黑树基础介绍

+ 红黑树是一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是 Red或 Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。
+ 红黑树在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，保证了一棵 n 个结点的红黑树始终保持了 Iogn 的高度，从而保证了红黑树的查找 、 插入、删除的时间复杂度最坏为 O(logn)。性质如下：
  + 每个结点要么是红的要么是黑的
  + 根结点是黑的
  + 每个叶结点都是黑的
  + 如果一个结点是红的，那么它的两个儿子都是黑的
  + 对于任意结点而言，从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
+ 对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质 。 可以通过对结点进行重新着色，以及对树进行相关的旋转操作，修改树中某些结点的颜色及指针结构，来达到操作后继续保持性质或平衡的目的 。

##### 2.哈希表

+ 哈希表是根据关键码的值而直接进行访问的数据结构。数组就是一张哈希表。 关键码是数组的索引下表，通过下表直接访问数组中的元素。
+ 一般哈希表都是用来快速判断一个元素是否出现集合里。
+ 哈希函数，把值直接映射到哈希表上的索引，通过查询索引快速知道值是否在表中。

+  **<font color = red>此时为了保证映射出来的索引数值都落在哈希表上，再次对数值做一个取模的操作，保证值可以映射到哈希表上了。</font>** 如果元素数量大于哈希表的大小，会有元素同时映射到同一个索引下表的位置。出现 **「哈希碰撞」**。

解决哈希碰撞的方法：

+ 拉链法：
  + 位置发生了冲突，发生冲突的元素都被存储在链表中。
  + 拉链法就是要选择适当的哈希表的大小，数组空值会浪费大量内存，链表太长会在查找上浪费太多时间。
+ 线性探测法：
  + 使用线性探测法，一定要保证tableSize大于dataSize。依靠哈希表中的空位来解决碰撞问题。
  + 例如冲突的位置，放了A，那么就向下找一个空位放置B的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据了。

---

### map

##### 1. map的本质与功能

+ `std::map` 是有序键值对容器，它的元素的键是唯一的。对于迭代器来说，不可以修改键值，只 能修改其对应的实值。 
+ map 通常实现为红黑树。具有对数据自动排序的功能，在 map 内部所有的数据都是有序的 。

##### 2. map的增删改查

+  **map类型值：**
  +  `key_type`：关键字类型
  + `mapped_type`：值类型
  + `value_type`是key-value对pair类型

+  **map的插入**

  + 插入 pair 数据：`map.insert(pair<type,type>(,))`
  + 插入 value_type 数据： `map.insert(map<type,type>::value_type(,))`
  + 数组的方式插入数据： `map[key_type] = mapped_type` ；可以覆盖修改原有数据

+  **map 的遍历**

  + auto 的方式来遍历

  + 利用迭代器：

    ```c++
    map<int , string>::iterator iter ;
    for(iter = Map.begin();iter ! = Map.end(); iter++)
      	cout << iter->first<< " " << iter->second << endl;
    ```

+  **map的查找**

  + 利用 count
  + 利用 find 
    + 数据出现时，返回数据所在位置的迭代器
    + 没有要查找的数据，返回 end() 迭代器 。

+  **map的删除**

  + 利用键值：`map.erase(k)` 返回 size_type类型的值以表示删除的元素个数
  + 利用迭代器：`map.erase(p)` 返回 void类型
  + 利用迭代器范围：`map.erase(b,e)` 返回 void类型 ；删除范围：[b,e)

  > 注意事项：利用迭代器删除时最好还是将输入的迭代器备份一下

##### 3. map排序

+ 按照 key 从大到小排序：
  + 定义时排序： `map<string, int, greater<string>> Map`
  + 利用vector：将map以pair对的形式导入vector，然后利用sort进行排序
    + `sort(v.begin(), v.end(),[](pair<int,string>a,pair<int,string>b){return a.first > b.first;});`
+ key(第一个元素)是一个结构体：在结构体中重载 < 运算符
+ 按照 value 进行排序： 
  + 利用 vector，将 first 修改成 second

---

##### 4. map的迭代器类型与数据成员：

+ 迭代器类型： `Bidirectional Iterator` 
+ 数据成员：一个指针指向红黑树；红黑树成员：一个size_t变量表示树的大小，一个header指针

---

##### 5. map 上常见操作的复杂度（效率）

- 搜索，移除和插入： $logn$

### set

##### 1.set的本质与功能

`std::set` 是关联容器，含有 `Key` 类型对象的已排序集。用比较函数 Compare 进行排序。搜索、移除和插入拥有对数复杂度。 `set` 通常以红黑树实现。

---

##### 2.为何 map 和 set 的插入删除效率比用其他序列容器高 ?

+ 因为关联容器不需要做内存拷贝和内存移动 。 set容器内所有元素都是以节点的方式来存储，节点结构和链表差不多
+ 插入只要把节点的指针指向新的节点；删除把指向删除节点的指针指向其他节点。 只需修改指针操作，和内存移动没有关系 。

---

##### 3.为何每次 insert之后，以前保存的 iterator不会 失效?

+ iterator相当于指向节点的指针，内存没有变，指向内存的指针不会失效。 
+ 对于vector，每一次删除和插入，指针都有可能失效，push_back也是如此 。 因为有时需要开辟新内存将原有数据移动入内，这样原指针全部失效。

---

##### 4.当数据元素增多时， set 的插入和搜索速度变化如何?

+ set使用的是二分查找，当数据量增大一倍的时候，搜索次数只不过多了 1 次。是$log2$的关系。

---

##### 5.set的增删查操作

+ set的插入操作
  + 在 pos位置之前插入 value，返回新元素位置
  + 将迭代区间[&first, &last)内所有的元素 ，插入到 set容器。
+ set的删除操作
  + `size_type erase(value)`移除 set容器内元素值为 value 的所有元素，返回移除的元素个数。
  + `void erase(&pos)`移除 pos位置上的元素，无返回值。
  + `void erase(&first, &last)`移除迭代区间``[&first, &last)``内的元素，无返回值 。
+ set的查找
  + `count(value)`返回 set对象内元素值为 value 的元素个数 。
  + `iterator find(value)`返回 value所在位置，找不到 value将返回 end()。

---

##### 6. set的迭代器类型与数据成员：

+ 迭代器类型： `Bidirectional Iterator` 
+ 数据成员：一个指针指向红黑树；红黑树成员：一个size_t变量表示树的大小，一个header指针

---

##### 7. set 上常见操作的复杂度（效率）

- 搜索，移除和插入： $logn$

### unordered_map 与 unordered_set

##### 介绍一下

+ multimap， unordered_set是关联容器，底层由 哈希表 实现。在内部，元素并不以任何特别顺序排序，而是组织进桶中，元素被放入哪个桶完全依赖其值的哈希。 两者的差别在于前者重复key 或者 重复 value 。STL默认使用拉链法来解决哈希冲突问题

---

##### 迭代器类型与数据成员：

+ 迭代器类型： `Forward Iterator` 
+ 数据成员：
  + 一个指针指向哈希表；
  + 哈希表内部成员：
    + 一个 size_t 变量表示哈希表中元素数量
    + 一个内部存放 node 结点指针的 vector

---

##### 常见操作的复杂度（效率）

- 插入，移除以及查询元素——常数 *O(1)*

---

### 容器适配器

+ Queue 先进先出，stack 先进后出；底层默认由 deque 实现
+ Priority_queue 优先队列，底层由 vector 实现，默认为大顶堆，提供 *O(1)* 复杂度的最大元素查询，  $O(logn)$ 代价的插入与释出

---

## 四.网络编程相关

+ 讲讲非阻塞socket
+ 文件读经历了哪些过程

---



### 1.socket

- **TCP进行socket编程的步骤**

  - 服务端和客户端初始化 socket ，得到文件描述符;
  - 服务端调用 bind ，将绑定在 IP 地址和端口;
  - 服务端调用 listen ，进行监听;
  - 服务端调用 accept ，等待客户端连接；
  - 客户端调用 connect ，向服务器端的地址和端口发起连接请求;
  - 服务端 accept 返回用于传输的 socket 的文件描述符;
  - 客户端调用 write 写入数据;服务端调用 read 读取数据;
  - 客户端断开连接时，会调用 close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ， 待处理完 数据后，
  - 服务端调用 close ，表示连接关闭。

- **服务器端会维护哪两个队列？** 

  - 未完成连接队列(SYN 队列):接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态; 
  - 已完成连接队列(Accpet 队列):已完成 TCP 三次握手过程，处于 ESTABLISHED 状态;

- **服务器端进行TCP连接(socket连接)时，内核的工作流程**

  - 当客户端发送的SYN请求报文到达后，插入到SYN 队列，随后给对方发送ACK确认报文
  - 当接收到客户端的ACK确认报文后，应用程序从Accpet 队列中取出已完成连接的socket

- **socket的各个步骤对应 TCP 握手中的哪些阶段？**

  - 客户端初始化 socket ，调用 connect 后，进入SYS-SENT状态，是第一次握手阶段
  - 服务器端初始化 socket ，调用 bind 绑定在 IP 地址和端口，调用 listen 进行监听后，进入Listen状态
  - 服务器端在接收到客户端的 SYN 请求报文后， 调用 accept ，等待客户端连接，并回复ACK确认报文，进入 SYN-RCVD状态
  - 客户端接收到ACK确认报文后，connect函数返回文件操作符，回复ACK确认报文，进入established状态
  - 服务器端收到对方的ACK确认报文后，accpet API 函数返回 文件操作符，进入established状态

- **为什么一个socket可以accept多次？**

  - 输入参数 fd 是从 socket， bind， listen 中沿用下来的 socket 句柄值，是在指定的端口处监昕所有的连接请求。
  - 调用 accept() 是从 socket fd 的请求队列抽取第一个连接信息，创建新的同类型 socket 句柄 fd 来进行后续操作。
  - 两个fd 是不同的，所以能 accept 多次

- **客户端调用close后，连接是断开的流程是什么?**

  - 就是四次挥手流程

- **IO有哪两种操作？**

  - 同步IO：必须等待 IO 操作完成后，控制权才返回给用户进程 。 
  - 异步IO：无须等待 IO 操作完成，就将控制权返回给用户进程 。 

- **网络IO发生时，设计哪些对象与操作？**

  - 会涉及两个系统对象：调用这个 IO 的 进程，系统内核。
  - 当一个 read操作发生时，会经历两个阶段:
    - 等待数据准备; 
    - 将数据从内核拷贝到进程中。

- **简单介绍一下4中IO模型。**

  - 阻塞IO：阻塞是指 IO 操作需要彻底完成后才返回到用户空间

    > 阻塞 IO 模型的特点就是：在 IO 执行的两个阶段(等待数据和拷贝数据)都被阻塞了 。

  - 非阻塞IO：非阻塞是指 IO 操作被调用后立即返回给用户一个状态值， 不需要等到 IO 操作彻底完成。

    > `fcntl( fd, F_SETFL, O_NONBLOCK );` 来设置socket成为非阻塞IO

  - 多路IO复用（事件驱动IO）：多路 IO复用 可以监视多个描述符， 一旦某个描述符就绪( 读就绪或写就绪)，能够通知程序进行相应的读写操作。 

    > 调用API后整个进程会被阻塞，而且存在两个系统调用(select与revcfrom)，如果连接数不多，不能体现优势。

  - 异步IO：

    - 用户角度：用户进程发起 read操作之后，立刻就可以开始去做其他的事;
    - 内核角度：当它收到一个异步的 read请求操作之后，首先会立刻返回，所以不会对用户进程产生任何阻塞。 然后，内核会等待数据准备完成，然后将数据拷贝到用户内存中，当这一切完成后，内核会给用户进程发送一个信号，返回 read操作已完成的信息 。

  > + 阻塞 IO、非阻塞 IO 及多路 IO 复用都属于同步 IO。
  > + 非阻塞 IO在执行 recvfrom 候，若内核的数据没有准备好，不会阻塞进程 。 但当内核中数据准备好时， recvfrom 会将数据从内核拷贝到用户内存中，这时进程仍被阻塞。 
  > + 异步 IO 不同， 当进程发起 IO 操作之后，就直接返回，直到内核发送一个信号，告诉进程 IO 已完成，整个过程中进程完全没有被阻塞。

---

### 2.IO复用

- **介绍一下 select 系统调用设计的函数**

  ```c++
  #include <sys/select.h>
  void FD_ZERO(fd_set *set); 						//把文件描述符集合里所有位清0
  void FD_CLR(int fd, fd_set *set); 		//把文件描述符集合里fd清0
  int  FD_ISSET(int fd, fd_set *set); 	//测试文件描述符集合里fd是否置1
  void FD_SET(int fd, fd_set *set); 		//把文件描述符集合里fd位置1
  
  struct timeval {
    	long tv_sec; /* seconds */  
    	long tv_usec; /* microseconds */
  };
  
  int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
             struct timeval *timeout);
  ```

  **参数：**

  + nfds： 指定被监听的文件描述符的总数。通常设置为被监听的所有fd中的最大值加1，因为fd从0开始计数的。

  + readfds：  监控有读数据到达文件描述符集合，传入传出参数

  + writefds： 监控写数据到达文件描述符集合，传入传出参数

  + exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数

  + timeout： 定时阻塞监控时间，3种情况

    1. NULL，永远等下去

    2. 设置timeval，等待固定时间

    3. 设置timeval里时间均为0，检查描述字后立即返回，轮询

  **返回值：**

  + 成功： **所监听的所有 监听集合中，满足条件的总数**
  + 失败： 返回 -1 并设置errno


---

+ **简单介绍一下select调用过程。**

  1. 在进行 `socket, bind, listen` 后，得到连接请求描述符 `listenfd`。设置数组`client[FD_SETSIZE]`存放文件描述符，全部初始化为 -1。

  2. 设置 存放文件描述符集合 `fd_set rset`，使用 `FD_ZERO(rset)` 进行清零，使用 `FD_SET(listenfd)` 将 `listenfd` 加入集合

  3. 设置 `maxfd = listenfd + 1` ，进行 while 循环，将 `rset` 赋给临时的` readset`，调用 `select` 函数

     > `select (maxfd, &readset,NULL, NULL, NULL)`

  4. 等待 `select` 有返回值时，得到就绪的文件操作符数目 `nready`，先进行判断是否合理，然后利用 `FD_ISSET(listenfd, &rset)`  判断是否有新的连接

  5. 如果有，则调用 `accept` ，返回连接后的文件描述符 `connfd` 。使用 `FD_SET(connfd, &readset); ` 将 `connfd` 放入 `readset` 集合中。

  6. 遍历 `client` 数组，将 `connfd` 放入合适位置，`nready--` 。最后更新 `maxfd`

  7. 随后遍历 client 数组，找出其中的 文件描述符， 使用 `FD_ISSET(sockfd, &rset)` 操作，判断是否存在读事件，如果是，则继续进行任务操作，如 read。  `nready--` 。

  8. 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。 

---

+ **介绍一下 poll 系统调用函数**

  ```c
  #include <poll.h>
  
  struct pollfd {
      int fd; /* 文件描述符 */
  		short events; /* 监控的事件：主要是 POLLIN,POLLOUT,POLLERR */
  		short revents; /* 监控事件中满足条件返回的事件，由内核填充 */
  };
  
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  ```

  **参数：**

  + fds： pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读，可写和异常等事件。
  + nfds： 指定被监听时间集合fds的大小。
  + timeout： 毫秒级等待
    + -1：阻塞等待，#define INFTIM -1         Linux中没有定义此宏
    + = 0：立即返回，不阻塞进程
    + \> 0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值

  **返回值：**

  + 成功： 所监听的所有 监听集合中，满足条件的总数
  + 失败： 返回 -1 并设置errno

---

+ **简单介绍一下poll调用过程。**

  + 定义 pollfd 结构体数组 `struct pollfd client[1024]`，将第一个`client[0]`设置fd与events设置为listenfd与POLLIN，其余fd为-1 ，设置maxi = 1。

  + 进行循环，调用 poll 函数， 返回就绪文件描述符个数，查看`client[0]`是否为 POLLIN事件(`client[0].revents & POLLIN`) 

    > `nready = poll(client, maxi, -1);`

  + 如果是，调用accept得到新的连接文件描述符connfd，将其存放到client数组中合适的位置。更新maxi,nready--。

  + 遍历前面`1-maxi`个client数组，找出就绪的文件描述符，查看是否为POLLIN事件，如果事，则进行下面的任务处理，nready--。

  + 当 `nready == 0` 时，while 循环跳出，结束。关闭 `listenfd`。

---

+ **介绍一下 epoll 系统调用函数**

  + epoll_create 函数：创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数

    ```c++
    #include <sys/epoll.h>
    
    int epoll_create(int size);
    ```

    + 参数：
      + size：监听数目(告诉Linux内核创建多大的epoll模型)，创建多大结点的红黑树，只是建议值，
    + 返回值：
      + 成功返回 文件描述符，指向红黑树的根
      + 失败返回 -1

  + epoll_ctl 函数：控制某个epoll监控的文件描述符上的事件：注册、修改、删除。

    ```c++
     #include <sys/epoll.h>
    
    struct epoll_event {
    			__uint32_t events; /* Epoll events */
    			epoll_data_t data; /* User data variable */
    };
    
    typedef union epoll_data {
        void *ptr;
        int fd;					//与epoll_ctl函数中的fd对应
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;
    
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    /*
    	epoll_event中的 events:
    	EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）
    	EPOLLOUT：	表示对应的文件描述符可以写
    	EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）
    	EPOLLERR：	表示对应的文件描述符发生错误
    	EPOLLHUP：	表示对应的文件描述符被挂断；
    	EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的
    	EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
    */
    ```

    + 参数：
      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根
      + op ： 在红黑树树上进心增删改：
        + EPOLL_CTL_ADD (注册新的fd到epfd)
        + EPOLL_CTL_MOD (修改已经注册的fd的监听事件)
        + EPOLL_CTL_DEL (从epfd删除一个fd)
      + fd ： 具体需要操作的文件描述符
      + event： 告诉内核需要监听的事件(往往只需要 events 与 data.fd)
    + 返回值：
      + 成功返回 0
      + 失败返回 -1

  + epoll_wait函数： 等待所监控文件描述符上有事件的产生，类似于 select() 调用。

    ```c++
    #include <sys/epoll.h>
    
    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
    ```

    + 参数：

      + epfd ： epoll_create成功返回的文件描述符，即红黑树树根

      + events ： 是一个传出参数数组

        > epoll_ctl中是传入变量的地址，这个变量初始化好就行
        >
        > epoll_wait中是传入数组，传出满足事件的文件描述符，每个元素都是epoll_event结构体

      + maxevents ： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，

      + timeout ：是超时时间

        +  -1： 阻塞
        +  0： 立即返回，非阻塞
        +  \>0： 指定毫秒

    + 返回值：

      + 成功返回有多少文件描述符就绪
      + 时间到时返回0，
      + 出错返回-1

---

+ **简单介绍一下 epoll 的调用过程**

  1. 通过 `epoll_create` 函数创建 epoll 模型，返回红黑树的根结点作为文件描述符 efd。

  2. 创建epoll_event事件与数组(`struct epoll_event tep, ep[OPEN_MAX]; `)，将tep的event设置为EPOLLIN，data.fd 设置为 listenfd。利用 epoll_ctl 函数将 listen 与 tep 添加到 efd 的红黑树中

     >  `res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &tep); `

  3. 循环，将 数组 ep 代入epoll_wait函数等待文件描述符就绪，当就绪后，返回就绪的文件描述符数目

     > ` nready = epoll_wait(efd, ep, OPEN_MAX, -1); ` 

  4. 循环 ep 数组中前 nready 个元素，查看是否是EPOLLIN事件(`ep[i].events & EPOLLIN`) 

  5. 如果是，则查看是否为listenfd 就绪(`ep[i].data.fd == listenfd`)，如果是，则调用accpet函数，返回新的连接文件描述符 connfd，重新赋值给 tep ，利用 epoll_ctl 函数将tep 加入红黑树中

  6. 如果不是listenfd 就绪，则取出，赋值给sockef，利用它来完成其他任务操作。

---

+ **介绍一下 epoll 的两种触发模式**

  + **Level Triggered (LT 水平触发)** ：epoll的默认触发方式，既支持阻塞模式，也支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。一次性读写完未全部完成，那么下次调用 epoll_wait()时，还会通知在上次没读写完的文件描述符上继续读写

  + **Edge Triggered (ET 边缘触发)** ： 只支持非阻塞模式，当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。一次性全部读写完未完成，那么下次调用epoll_wait()时，不会通知，即只会通知一次，直到该文件描述符上出现第二次可读写事件。

    > 最好是利用边缘触发，使用非阻塞fd，套上while循环将数据一次性读写完成，这样效率更高。

---

+  **在ET模式下当多个连接同时到达时该怎么处理？**

   + 理论上如果多个连接同时到达，服务器的TCP就绪队列瞬间积累多个就绪连接，由于是边缘触发模式，epoll只会通知一次，accept只处理一个连接，导致TCP就绪队列中剩下的连接都得不到处理。

   + 解决办法是用while循环包住accept调用，处理完TCP就绪队列中的所有连接后再退出循环。如何知道是否处理完就绪队列中的所有连接呢？accept返回-1并且errno设置为EAGAIN就表示所有连接都处理完。

---

+  **nigix的实现中多个连接同时到达如何处理？**
   + nigix 中 ，accept函数调用使用水平触发的fd，就是出于对丢失连接的考虑，所以不存在丢失连接的问题。
   + 但是若系统中有大量不需要读写的就绪文件描述符，而它们每次都会返回，会大大降低处理程序检索自己关心的就绪文件描述符的效率。

---

+ **使用Linux epoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？**
  + 平时不要把该描述符放进event_poll结构体中，当需要写该fd的时候，调用epoll_ctl把fd加入eventpoll里监听，可写的时候就往里写，写完再次调用epoll_ctl把fd移出event_poll，这种方法在发送很少数据的时候仍要执行两次epoll_ctl操作，有一定的操作代价
  + 改进一下就是：平时不要把该描述符放进event_poll结构体中，需要写的时候调用write或者send写数据，如果返回值是EAGAIN（写缓冲区满了），那么这时候才执行第一种方法的步骤。

---

+ **比较IO复用 select，poll，epoll 的区别**

  + select、 poll和 epoll都是多路 IO 复用机制。 可以监视多个描述符， 一旦某个描述符就绪，会通知程序进行相应的读写操作。 但它们本质上都是同步 IO，因为它们都需要在读写事件就绪后自己负责进行读写，是阻塞的。

  + select的优缺点：

    + select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。
    + select()对于超时值提供了更好的精度，而 poll()是精度较差。
    + select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024
    + select采用的是轮询模型，如果链接客户端过多，会大大降低服务器响应效率

  + poll的优缺点：

    + 可以修改文件描述符的上限数目，优于select
    + 将监听集合 和 返回集合 实现了分离，不像select那么麻烦，搜索范围更小
    + poll在应付大数目的文件描述符时速度更快，对于 select 来说内核需要检查大量描述符对应的set中的每一个比特位，比较费时。
    + 但还是需要将数组全部变量，找出已连接的文件描述符，而不是直接返回满足的文件描述符数组。

  + epoll 的优点

    + 支持ET触发模式，其余两者只支持LT。

    + 不是使用轮询的方式，不会随着fd数目的增加效率下降。只有活跃可用的fd才会调用callback函数；selet 与 poll 调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。

    + 使用 mmap加速内核与用户空间的消息传递

      > 3者都需要内核把fd消息通知给用户空间，如何避免不必要的内存拷贝就显得尤为重要 。 
      >
      > epoll 通过内核 与用户空间 mmap 处于同一块内存实现的 。
      >
      > poll将传入的 pollfd数组拷贝到内核空间，因为拷贝操作和数组长度相关，时间上来看，这是一个 O(n)操作

---

+ Libevent如何处理IO事件，信号事件，和定时事件








---







---

## 五.WebServer项目相关

* 利用正则与状态机解析HTTP请求报文，实现处理静态资源的请求；
* 利用标准库容器封装char，实现自动增长的缓冲区；
* 基于小根堆实现的定时器，关闭超时的非活动连接；

---

##### 介绍一下项目的流程

+ epoll事件进行监听，如果有读事件，则主线程直接调用 read 将数据全部读入缓冲区
+ 数据读完之后，将任务封装成 http_conn 类，线程池中子线程取出一个任务，执行任务中的process函数
  + 首先解析 HTTP 请求
  + 根据 HTTP 请求寻找资源，生成HTTP响应，通过分散写的方式将 响应头与响应文件一起写入
+ 当epoll监听到写事件时，主线程直接调用 write 将数据写给客户端进程

---

+ 解析消息的流程process
  + 解析消息 process_read
    + 当解析遇到空行时，说明消息头部字段解析完成，接下来解析的就是消息体
    + 如果不是空行，则进行解析消息头的各个信息，比如connect，等等
    + 等消息解析完之后就去分析目标文件的属性
  + 分析目标文件的属性 do_request
    + 将服务器中的资源根目录与请求内容结合，找到对应的资源的路径
    + 然后分析路径与权限是否合法
    + 最后打开寻找的路径的文件，创建内存映射，将需要写回的资源映射到地址上，等待之后的发送
  + 生成响应 process_write
    + 判断解析请求的返回值，根据请求结果来做对应的操作，如No resource等
      + 添加响应状态行，响应头
    + 将消息头和消息体分散写 write，使用writv
      + 消息头就是上面根据请求来设置的消息头内容
      + 消息体是mmap映射的资源

---

##### **介绍一下你的WebServer项目**

+ 自己用C++11改写了一个简单的Reactor高并发模型服务器。主线程初始化一个线程池，然后进行绑定IP与端口，创建socket socketfd，利用IO复用技术Epoll创建epoll模型efd，将socketfd添加至EPOLL中，进行监听事件与数据读写。定义httpconn类封装任务事件，定义httpconn类数组users；
+ 如果监听到连接事件发生，则进行accpet连接，新建socket文件描述符 connfd ，然后将连接的用户数据放入 users 数组中并初始化，顺便添加至epoll中进行监听。
+ 如果有EPOLLIN事件，则先将对应connfd的数据一次性读完，然后将任务添加到线程池中的任务队列中，让线程池中的线程进行逻辑任务操作，即解析HTTP请求，生成响应发送。
+ 如果有EPOLLOUT事件，则将将数据一次性写完

---

##### **介绍一下服务器程序中的事件处理模式**

+ 简单介绍：
  + Reactor模式：利用I/O复用，让主线程调用 epoll_wait 等待 socket 上有数据可读与可写。当epoll_wait 通知主线程后，主线程将 socket 事件放入请求队列，唤醒的线程来处理数据的读写与后续的业务逻辑
  + Proactor模式：利用 异步I/O aio_read 与 aio_write 让内核来进行 socket 的读写操作，等操作完成后内核通知主线程，主线程将唤醒工作线程来处理后续的业务逻辑与事件注册
  + 同步IO模拟Proactor模式： 主线程调用 epoll_wait 等待 socket 上有数据可读与可写。当epoll_wait 通知主线程后，主线程将数据读完之后封装成请求队列中的元素，唤醒工作线程完成后续的逻辑业务与事件注册。
+ **Reactor模式**
  + 要求主线程 (I/O处理单元) 只负责监听文件描述上是否有事件发生，有则立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，工作线程不做任何实质性的工作。读写数据，连接新的连接，处理客户请求接在工作线程完成。
  + 使用同步 I/O 模型实现的工作流程：
    1. 主线程 在epoll 内核事件表中注册 socket 的读就绪事件
    2. 主线程调用 epoll_wait 等待 socket 上有数据可读
    3. 有数据可读时，epoll_wait 通知主线程，主线程将 socket 可读事件放入请求队列
    4. 睡眠在请求队列中的某个工作线程被唤醒，它从socket 读取数据，并处理客户请求，然后往 epoll 事件表中注册 socket 上的写就绪事件
    5. 主线程调用 epoll_wait 等待 socket 可写
    6. socket 可写时， epoll_wait 通知主线程，主线程将 socket 可写事件放入请求队列
    7. 睡眠在请求队列中的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果
+  **Proactor模式：**
  + 将所有I/O操作都交给主线程和内核处理(读写)，工作线程只负责业务逻辑。
  + 使用异步I/O模型实现的工作流程：
    1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核 用户读缓冲区的位置，以及读操作完成时如何通知应用程序，可用信号
    2. 主线程继续处理其他逻辑
    3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送信号，通知数据可用
    4. 应用程序预先定义的信号处理函数选择一个工作线程来处理客户请求。处理完成之后调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核 用户写缓冲区的位置，以及写操作完成时如何通知应用程序
    5. 主线程继续处理其他逻辑
    6. 当用户缓冲区数据写入 socket 后，内核将向应用程序发送信号，通知数据已发送
    7. 应用程序预先定义的信号处理函数选择一个工作线程做善后工作，比如是否关闭socket
+  **同步I/O模拟Proactor模式：**
  + 主线程执行数据读写操作，完成之后主线程向工作线程通知这一"完成事件"。从工作线程的角度看，它们只需对读写的结果进行逻辑处理。
  + 使用同步 I/O 模型模拟出Proactor模式的工作流程如下：
    1. 主线程 在epoll 内核事件表中注册 socket 的读就绪事件
    2. 主线程调用 epoll_wait 等待 socket 上有数据可读
    3. 有数据可读时，epoll_wait 通知主线程，主线程从 socket 中循环读完数据，将数据封装成一个请求对象放入请求队列
    4. 睡眠在请求队列中的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 事件表中注册 socket 上的写就绪事件
    5. 主线程调用 epoll_wait 等待 socket 可写
    6. socket 可写时， epoll_wait 通知主线程，主线程往 socket 上写入服务器处理客户请求的结果

---

##### **线程池的优点是什么？**

+ 线程池旨在降低创建和销毁线程的频率，使其维持合理数量的线程，并让空闲的线程重新承担新的任务 。
+ 连接池是指维持连接的缓存池，尽量重用已有的连接，降低创建和关闭连接的频率。
+ 这两种技术能降低系统开销，但当请求数目远远大于池中元素的数目时，没有显著的效果。特别是在阻塞IO下。

---

##### 你是怎么设计线程池的？

+ 定义了一个ThreadPool类，其中的将一个Pool类与Pool类型的智能指针pool。其中Pool类有四个元素，分别为：
  + mutex锁 mtx
  + 条件变量 cond
  + bool 类型的标志，表示是否关闭线程池
  + 任务队列 tasks，元素是Function函数
+ 首先定义构造函数：
  + 默认传入参数ThreadCount表示创建8个线程，初试列表中动态创建一个动态指针对象，即定义一个线程池。
  + 在构造函数体中，进行for循环，利用Thread函数创建线程，并设置为分离detach，其中thread参数是lambda函数，在lambda函数中，将新建的线程池对象传入其中，lambda函数体中先用unique_lock锁住，然后进行while循环，不断取出任务队列，进行任务操作，当队列为空时，阻塞等待有工作线程入队的通知
+ 定义析构函数，析构函数体中将bool 标志设置为关闭线程池，通知所有线程，则所有线程函数都break while循环
+ 定义添加任务函数 AddTask，首先进行lock_guard加锁，然后将传来的task参数初始化封装成任务，并添加到任务队列中。解锁，并利用条件变量通知线程池中的一个线程。

```c++
//条件变量的定义：
std::condition_variable cond;
std::mutex mtx;
std::unique_lock<std::mutex> locker(mtx);
//条件变量进行阻塞
cond.wait(locker);
//唤醒所有线程
cond.notify_all();
//唤醒一个线程
cond.notify_one(); 
```

---

+  项目里实现了哪些HTTP请求呢，处理的时候如何分辨这些请求呢？
+  设想这样一种场景，我的web服务器里面有一张表格，现在浏览器需要请求这个表格中 id=张三 的内容，同时返回到浏览器也需要以表格的形式展现。

---

##### 为什么需要定时器

+ 因为系统中的文件描述符资源有限，如果一直存在不活跃的文件描述符，会消耗文件资源
+ 

---

## 六.智力题









---

## 七综合面试

+ 智力题 楼层丢鸡蛋
+ 8个赛道，64匹马，要选前4，需要多少轮。
+ 一个检测试剂10分钟检测一位病人，工厂有1000人，最少多少支试剂能10分钟内检测出来哪一位患病？讲出原理（小猪喝水问题的变种
+ 1-100，报号，每次剔除奇数位置的人，问这样剔除以后最后剩下的是几号？64
+ 自我介绍，将自己的经历和项目做一些介绍； 
+ 自己所做邻域的国内外现状、学术界和工业界的状况（因为我研究生期间做的内容比较小众）； 
+ 应聘季自己应聘的优势和劣势； 
+ 对华为的文化怎么理解； 
+ 自己最喜欢的学习方式； 
+ 将来的职业规划；