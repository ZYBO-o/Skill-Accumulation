## C++面试知识整理

<!-- GFM-TOC -->

* [1.在main执行之前和之后执行的代码可能是什么？](#1在main执行之前和之后执行的代码可能是什么)
* [2.结构体内存对齐问题？](#2结构体内存对齐问题)
* [3.指针和引用的区别](#3指针和引用的区别)
* [4.堆和栈的区别](#4堆和栈的区别)
* [5.区别以下指针类型？](#5区别以下指针类型)
* [6.基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间](#6基类的虚函数表存放在内存的什么区虚表指针vptr的初始化时间)
* [7.new / delete 与 malloc / free的异同](#7new--delete-与-malloc--free的异同exit)
* [8.new和delete是如何实现的？](#8new和delete是如何实现的)
* [9.malloc和new的区别？](#9malloc和new的区别)
* [10宏定义和函数有何区别？](#10宏定义和函数有何区别)
* [11.宏定义和typedef区别？](#11宏定义和typedef区别)
* [12.变量声明和定义区别？](#12变量声明和定义区别)
* [13.哪几种情况必须用到初始化成员列表？](#13哪几种情况必须用到初始化成员列表)
* [14.strlen和sizeof区别？](#14strlen和sizeof区别)
* [16.a和&a有什么区别？](#16a和a有什么区别)
* [17.数组名和指针（这里为指向数组首元素的指针）区别？](#17数组名和指针这里为指向数组首元素的指针区别)
* [18.野指针和悬空指针](#18野指针和悬空指针)
* [19.迭代器失效的情况](#19迭代器失效的情况)
* [20.C和C++的区别](#20c和c的区别)
* [21.C++与Java的区别]()
* [22.C++中struct和class的区别](#22c中struct和class的区别)
* [23.define宏定义和const的区别](#23define宏定义和const的区别)
* [24.C++中const和static的作用](#24c中const和static的作用)
* [25.C++的顶层const和底层const](#25c的顶层const和底层const)
* [26.类的对象存储空间？](#26类的对象存储空间)
* [27.final和override关键字](#27final和override关键字)
* [28.拷贝初始化和直接初始化](#28拷贝初始化和直接初始化)
* [29.初始化和赋值的区别](#29初始化和赋值的区别)
* [30.extern"C"的用法](#30externc的用法)
* [31.模板函数和模板类的特例化](#31模板函数和模板类的特例化)
* [32.C和C++的类型安全](#32c和c的类型安全)
* [33.为什么析构函数一般写成虚函数](#33为什么析构函数一般写成虚函数)
* [34.构造函数能否声明为虚函数或者纯虚函数，析构函数呢？](#34构造函数能否声明为虚函数或者纯虚函数析构函数呢)
* [35.C++中的重载、重写（覆盖）和隐藏的区别](#35c中的重载重写覆盖和隐藏的区别)
* [36.C++的多态如何实现](#36c的多态如何实现)
* [37.C++有哪几种的构造函数](#37c有哪几种的构造函数)
* [38.浅拷贝和深拷贝的区别](#38浅拷贝和深拷贝的区别)
* [39.内联函数和宏定义的区别](#39内联函数和宏定义的区别)
* [40.构造函数、析构函数、虚函数可否声明为内联函数](#40构造函数析构函数虚函数可否声明为内联函数)
* [41.auto、decltype和decltype(auto)的用法](#41autodecltype和decltypeauto的用法)
* [42.public，protected和private访问和继承权限/public/protected/private的区别？](#42publicprotected和private访问和继承权限publicprotectedprivate的区别)
* [43.如何用代码判断大小端存储](#43如何用代码判断大小端存储)
* [44.volatile、mutable和explicit关键字的用法](#44volatilemutable和explicit关键字的用法)
* [45.什么情况下会调用拷贝构造函数](#45什么情况下会调用拷贝构造函数)
* [46.C++中有几种类型的new](#46c中有几种类型的new)
* [47.C++中NULL和nullptr区别](#47c中null和nullptr区别)
* [48.简要说明C++的内存分区](#48简要说明c的内存分区)
* [49.C++的异常处理的方法](#49c的异常处理的方法)

<!-- GFM-TOC -->

---

### 1.在main执行之前和之后执行的代码可能是什么？

> 操作系统装载程序之后，首先运行的代码并不是main的第一行，而是某些特别的代码，这些代码准备好main函数执行说需要的环境，并且负责调用main函数，这时候你才可以再main函数里放心大胆的写各种代码：申请内存、使用系统调用、触发异常、访问IO。在main函数返回之后，他会记录main函数的返回值，调用atexit注册的函数，然后结束进程。
>  ——《程序员的自我修养--链接、装载与库》

#### main函数之前

简单来说，main函数之前，主要做了这些：

+ 配置堆栈
+ 初始化静态和全局变量
+ 为未初始化部分的全局变量赋值
+ 运行全局构造器
+ 将main函数的参数（argv，argc等）传递给main函数

这些基本都是变量、环境的配置。因此，如果想执行一段代码，最简单的办法就只有一个了：利用构造函数。
大方向敲定，那么剩下的小细节无非就是类放在哪的问题了。

+ 全局变量

+ 静态变量

+ `include`文件中的全局或静态变量

+ `namespace`中

+ 等等…

比如：

```c++
class A{
public:
    A(){
        cout << "before main()" << endl;
    }
    ~A(){
        cout << "after main()" << endl;
    }
}

A a; //全局变量

int main(){
    cout << "this is in main()" << endl;
    return 0;
}
```

#### main函数之后

- 全局对象的析构函数会在main函数之后执行；

- 可以用 **atexit** 注册一个函数，它会在main 之后执行;

  > `onexit( func )`（对于C）或 `atexit( func )`（对于C++）。不过这两个函数有一点小小的差别：
  >
  > + onexit( func ) 要求注册的函数func返回值为int型；
  > + atexit( func ) 要求函数没有返回值，即返回值类型为void；
  >
  > 不过这两个函数都要求函数没有传入参数。

```c++
void func2(void){
    cout << "function 2" << endl;
}

int main() {
	cout << "this is main 1" << endl;
	atexit(func2);
	cout << "this is main 2" << endl;
        return 0;
}
```

输出：

```shell
this is main 1
this is main 2
function 2
```

---







---

### 



---

### 11

---





---



---

### 20.

---

- 

---



---

> 

---

### 32.

---

> 

---

> 

---



---

### 49.
