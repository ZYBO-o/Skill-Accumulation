## 一.并发的途径

并发有两种基本途径。每个开发人员代表一个线程，每个办公室代表一个进程。

+ 第一种途径是每个进程只要一个线程，这就类似让每个开发人员拥有自己的办公室
+ 第二种途径是每个进程有多个线程，如同一个办公室里有两个开发人员。

让我们在一个应用程序中简单的分析一下这两种途径。

### 1. 多进程并发

使用多进程并发，是将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。独立的进程可以通过进程间常规的通信渠道传递讯息(信号、套接字、文件、管道等等)。

##### 缺点：

+ 进程之间的通信通常不是设置复杂，就是速度慢，这是因为操作系统会在进程间提供了一定的保护措施，以避免一个进程去修改另一个进程的数据。
+ 运行多个进程所需的固定开销：需要时间启动进程，操作系统需要内部资源来管理进程，等等。

##### 优点

+ 操作系统在进程间提供附加的保护操作和更高级别的通信机制，意味着可以更容易编写安全的并发代码。实际上，在类似于Erlang的编程环境中，将进程作为并发的基本构造块。
+ 可以使用远程连接(可能需要联网)的方式，在不同的机器上运行独立的进程。虽然，这增加了通信成本，但在设计精良的系统上，这可能是一个提高并行可用行和性能的低成本方式。

### 2.多线程并发

在单个进程中运行多个线程。线程很像轻量级的进程：每个线程相互独立运行，且线程可以在不同的指令序列中运行。但是，进程中的所有线程都共享地址空间，并且所有线程访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。

##### 优点：

+ 虽然，进程之间通常共享内存，但是这种共享通常是难以建立和管理的。因为，同一数据的内存地址在不同的进程中是不相同。线程会好很多
+ 地址空间共享，以及缺少线程间数据的保护，使得操作系统的记录工作量减小，所以使用多线程相关的开销远远小于使用多个进程。

##### 缺点：

+ 共享内存的灵活性是有代价的：如果数据要被多个线程访问，那么程序员必须确保每个线程所访问到的数据是一致的
+ 线程间数据共享可能会遇到的问题，以及如何使用工具来避免这些问题。问题并非无解，只要在编写代码时适当地注意即可，这同样也意味着需要对线程通信做大量的工作。

---

## 二.使用并发的原因

### 1.为了分离关注点

+ 通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。
+ 又是因为功能以及业务，线程的数量不再依赖CPU中的可用内核的数量，因为对线程的划分是基于概念上的设计，而不是一种增加吞吐量的尝试。

### 2.为了性能

两种方式利用并发提高性能：

+ 第一，将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。这就是 **任务并行（*task parallelism*）。**

  >  虽然这听起来很直观，但它是一个相当复杂的过程，因为在各个部分之间可能存在着依赖。区别可能是在过程方面——一个线程执行算法的一部分

+ 而另一个线程执行算法的另一个部分——或是在数据方面——每个线程在不同的数据部分上执行相同的操作（第二种方式）。后一种方法被称为 **数据并行（*data parallelism*）。**

### 3.何时不用并发

+ 当收益比不上成本。使用并发的代码在很多情况下难以理解，因此编写和维护的多线程代码就会产生直接的脑力成本，同时额外的复杂性也可能引起更多的错误。

---

## 三. C++中的并发与多线程

### 1.C++多线程历史

编译器供应商可以自由地向语言添加扩展，添加C语言中流行的多线程API———POSIX标准中的C标准和Microsoft Windows API中的那些———这就使得很多C++编译器供应商通过各种平台相关扩展来支持多线程。

这种编译器支持一般受限于只能使用平台相关的C语言API，并且该C++运行库(例如,异常处理机制的代码)能在多线程情况下正常工作。因为编译器和处理器的实际表现很不错了，所以在少数编译器供应商提供正式的多线程感知内存模型之前，程序员们已经编写了大量的C++多线程程序了。

### 2.新标准支持并发

所有的这些随着C++11标准的发布而改变了，新标准中不仅有了一个全新的线程感知内存模型，C++标准库也扩展了：包含了用于管理线程(参见第2章)、保护共享数据(参见第3章)、线程间同步操作(参见第4章)，以及低级原子操作(参见第5章)的各种类。

---

